import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,e as s,a as l,b as a}from"./app-964156bf.js";const t={},r=s('<h1 id="_2024-春-操作系统-课程笔记" tabindex="-1"><a class="header-anchor" href="#_2024-春-操作系统-课程笔记" aria-hidden="true">#</a> 2024 春 操作系统 课程笔记</h1><h2 id="第一章-并发" tabindex="-1"><a class="header-anchor" href="#第一章-并发" aria-hidden="true">#</a> 第一章 并发</h2><h3 id="_1-多处理器编程" tabindex="-1"><a class="header-anchor" href="#_1-多处理器编程" aria-hidden="true">#</a> 1 多处理器编程</h3><h4 id="阿姆达尔定律" tabindex="-1"><a class="header-anchor" href="#阿姆达尔定律" aria-hidden="true">#</a> 阿姆达尔定律</h4>',4),m=l("p",null,[a("假设程序中可被并行化部分的比例为"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),l("span",{class:"mord mathnormal"},"p")])])]),a("，则在有"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal"},"n")])])]),a("个并行执行流的情况下，程序的加速比"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"p"),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"d"),l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"speedp")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),l("span",{class:"mord mathnormal"},"s"),l("span",{class:"mord mathnormal"},"p"),l("span",{class:"mord mathnormal"},"ee"),l("span",{class:"mord mathnormal"},"d"),l("span",{class:"mord mathnormal"},"p")])])]),a("为")],-1),c=l("p",{class:"katex-block"},[l("span",{class:"katex-display"},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"p"),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"d"),l("mi",null,"p"),l("mo",null,"="),l("mfrac",null,[l("mn",null,"1"),l("mrow",null,[l("mn",null,"1"),l("mo",null,"−"),l("mi",null,"p"),l("mo",null,"+"),l("mfrac",null,[l("mi",null,"p"),l("mi",null,"n")])])])]),l("annotation",{encoding:"application/x-tex"}," speedp = \\frac{1}{1 - p + \\frac{p}{n}} ")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),l("span",{class:"mord mathnormal"},"s"),l("span",{class:"mord mathnormal"},"p"),l("span",{class:"mord mathnormal"},"ee"),l("span",{class:"mord mathnormal"},"d"),l("span",{class:"mord mathnormal"},"p"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"2.3524em","vertical-align":"-1.031em"}}),l("span",{class:"mord"},[l("span",{class:"mopen nulldelimiter"}),l("span",{class:"mfrac"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"1.3214em"}},[l("span",{style:{top:"-2.314em"}},[l("span",{class:"pstrut",style:{height:"3em"}}),l("span",{class:"mord"},[l("span",{class:"mord"},"1"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mord mathnormal"},"p"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mord"},[l("span",{class:"mopen nulldelimiter"}),l("span",{class:"mfrac"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.7475em"}},[l("span",{style:{top:"-2.655em"}},[l("span",{class:"pstrut",style:{height:"3em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mathnormal mtight"},"n")])])]),l("span",{style:{top:"-3.23em"}},[l("span",{class:"pstrut",style:{height:"3em"}}),l("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),l("span",{style:{top:"-3.4461em"}},[l("span",{class:"pstrut",style:{height:"3em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mathnormal mtight"},"p")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.345em"}},[l("span")])])])]),l("span",{class:"mclose nulldelimiter"})])])]),l("span",{style:{top:"-3.23em"}},[l("span",{class:"pstrut",style:{height:"3em"}}),l("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),l("span",{style:{top:"-3.677em"}},[l("span",{class:"pstrut",style:{height:"3em"}}),l("span",{class:"mord"},[l("span",{class:"mord"},"1")])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"1.031em"}},[l("span")])])])]),l("span",{class:"mclose nulldelimiter"})])])])])])],-1),h=s(`<h4 id="posix-线程api" tabindex="-1"><a class="header-anchor" href="#posix-线程api" aria-hidden="true">#</a> POSIX 线程API</h4><ul><li><code>Pthread_create (pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void*), void * arg)</code><ul><li>创建线程<code>thread</code>并以参数<code>arg</code>运行函数<code>start_routine</code>.</li></ul></li><li><code>Pthread_exit (void* retval)</code><ul><li>在调用时结束调用者线程，并向<code>join</code>自身的调用者线程返回<code>retval</code>.</li></ul></li><li><code>Pthread_join (pthread_t thread, void** retval)</code><ul><li>阻塞当前线程，直到<code>thread</code>返回；返回值存放至<code>retval</code>内存中。</li></ul></li><li><code>Pthread_detach (pthread_t thread)</code><ul><li>令该线程处于分离状态，不需要也不能被<code>join</code>。<strong>处于分离状态的线程结束后将自动释放资源（否则需要手动<code>join</code>来回收占用的资源）。</strong></li></ul></li></ul><h4 id="内存一致性模型" tabindex="-1"><a class="header-anchor" href="#内存一致性模型" aria-hidden="true">#</a> 内存一致性模型</h4><p>现代处理器允许指令乱序执行，来减少某些高时延访存指令的影响；然而该技术会使得多个处理器看到的访存顺序并不相同。</p><p><strong>内存一致性模型</strong>（内存模型）定义了不同核心对于共享内存操作需要遵守的顺序。</p><ul><li>顺序一致性模型 <ul><li>提供了两个保证： <ul><li>不同核心看到的访存操作顺序一致（全局顺序）——每一个时间单位上只能有一个线程进行一次读 / 写。</li><li>在全局顺序中，每个核心自己的读写操作 <strong>与程序顺序</strong>（代码中的顺序）<strong>保持一致</strong>。</li></ul></li></ul></li><li>TSO (Total Store Ordering) <ul><li>保证对不同地址、没有依赖的[读-读，写-写，读-写]操作之间的全局可见顺序，但不保证[写-读]的全局可见顺序。</li><li>为每个线程都增加一个写缓存(local write queue)；</li><li>每个线程的写操作会先写到写缓存中，由写缓存写入共享内存；</li><li>写缓存写入共享内存的顺序一致且符合程序顺序。</li><li>每个线程的读操作会先从写缓存中读取，再从共享内存中读取，但无法读取其他现成的写缓存——因此，每个线程都最先看到自己的写操作（造成的结果），所以无法保证写-读的全局可见顺序（其他线程写入后，本线程不保证能读取到最新的值）。</li></ul></li><li>宽松内存模型 <ul><li>不保证任何不同地址、无依赖的访存操作之间的顺序。</li></ul></li></ul><h3 id="_2-互斥" tabindex="-1"><a class="header-anchor" href="#_2-互斥" aria-hidden="true">#</a> 2 互斥</h3><h4 id="一些概念" tabindex="-1"><a class="header-anchor" href="#一些概念" aria-hidden="true">#</a> 一些概念</h4><ul><li>临界区：访问共享资源的代码</li><li>竞态条件：多个执行线程大致同时进入临界区时，视图同时更新共享的数据结构，导致非预期的结果。</li></ul><h4 id="临界区的解决方案" tabindex="-1"><a class="header-anchor" href="#临界区的解决方案" aria-hidden="true">#</a> 临界区的解决方案</h4><ul><li>互斥：临界区内最多一个线程</li><li>行进：如果临界区内没有线程且有线程想要进入临界区，则最终会有线程进入临界区</li><li>有界等待：某个线程想要进入临界区的等待期限有限</li></ul><h4 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h4><p>锁的状态：</p><ul><li>可用：没有线程持有锁</li><li>占用：某个线程正持有锁，处于临界区</li></ul><h4 id="peterson-算法" tabindex="-1"><a class="header-anchor" href="#peterson-算法" aria-hidden="true">#</a> Peterson 算法</h4><div class="language-C++ line-numbers-mode" data-ext="C++"><pre class="language-C++"><code>int intents[2] = {0, 0}; //进⼊意图
int flag = 0; // 当前是谁可以获得锁 (thread 0 or 1)
int self = i; //当前的线程ID，0， 1中的⼀个

void lock() 
{
 intents[self] = 1; // 标记⾃⼰想要进⼊临界区
 flag = self; //轮转到下⼀位
 while ( (intents[(self + 1)%2] == 1) //别⼈想不想要进来
 &amp;&amp; (flag == self) ); // 如果别⼈也想进来，就再看看是否当前“轮转”到⾃⼰了
}
void unlock() 
{
  intents[self] = 0; //标记⾃⼰不再想要进⼊临界区
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="cmpxchg" tabindex="-1"><a class="header-anchor" href="#cmpxchg" aria-hidden="true">#</a> <code>cmpxchg</code></h4><p><code>cmpxchg</code>是x86体系下的一条原子指令。</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>cmpxchg %dest, %src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果<code>%dest == %src</code>: 将<code>%src</code>的值赋予<code>%dest</code>，设置<code>ZF</code>标志位</li><li>如果<code>%dest != %src</code>: 将<code>%dest</code>的值赋予<code>%AL</code>, 清除<code>ZF</code>标志位</li></ul><h4 id="排号自旋锁" tabindex="-1"><a class="header-anchor" href="#排号自旋锁" aria-hidden="true">#</a> 排号自旋锁</h4><ul><li>每个申请排队自旋锁的线程都会获得一个排队号（ticket）。</li><li>至多只有一个线程拥有自旋锁。</li><li>当持有自旋锁的线程释放锁时，它会将自身的ticket加1，并将其作为下一个可获得锁的ticket。</li><li>每个线程都会不断检查当前可服务的ticket是否等于自己的ticket。如果相等，则该线程就获得了自旋锁。</li><li><strong>适用于临界区较短的情况</strong>。</li></ul><h3 id="_3-同步" tabindex="-1"><a class="header-anchor" href="#_3-同步" aria-hidden="true">#</a> 3 同步</h3><h4 id="条件变量" tabindex="-1"><a class="header-anchor" href="#条件变量" aria-hidden="true">#</a> 条件变量</h4><p>用于标记某个同步条件的变量（满足 / 不满足），有两个方法：</p><ul><li><code>cond_wait</code>: 阻塞当前线程，等待某个条件变量满足。</li><li><code>cond_signal</code>: 唤醒一个阻塞在某个条件变量上的线程（当前条件已经满足）。</li><li><code>cond_broadcast</code>: 唤醒所有阻塞在当前条件变量上的线程，每个线程依据自身的条件判断是否继续阻塞。</li></ul><h4 id="hansen-mesa-语义-hoare-语义" tabindex="-1"><a class="header-anchor" href="#hansen-mesa-语义-hoare-语义" aria-hidden="true">#</a> Hansen / Mesa 语义 &amp; Hoare 语义</h4><p>Hansen / Mesa 语义实现的条件变量在调用者的<code>cond_signal</code>和转移到被唤醒者的<code>cond_wait</code>不是原子的，而Hoare语义的实现不是原子的。</p><p>Hoare语义较简洁（理论友好）但不好实现，因此大多数实现都使用 Hansen / Mesa 语义。</p><h4 id="条件变量的使用经验法则" tabindex="-1"><a class="header-anchor" href="#条件变量的使用经验法则" aria-hidden="true">#</a> 条件变量的使用经验法则</h4><ul><li>除了条件变量外，还得有共享的状态用来进行判定是否可以“生产”或者“消费” （如生产-消费问题中的“缓冲栈大小”）</li><li>使用互斥锁来保护共享的状态以及条件变量的操作</li><li>在做wait/signal/broadcast 时需<strong>要持有互斥锁</strong></li><li>每次从wait中唤醒，要重新进行条件检查（Use a while loop）</li><li>针对不同的条件使用不同的条件变量（除非使用broadcast）。</li></ul><h4 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量" aria-hidden="true">#</a> 信号量</h4><p>一个与同步有关的原语，代表一个 <strong>整数变量<code>sem</code></strong>；只有两种原子操作能改变该变量。</p><ul><li><code>P()</code>（“检验”） / <code>decrease()</code> / <code>wait()</code> / <code>acquire()</code>: <ul><li>如果<code>sem &lt;= 0</code>，阻塞当前线程</li><li>否则，<code>sem -= 1</code>，继续运行</li></ul></li><li><code>V()</code> （“自增”） / <code>increase</code> / <code>signal()</code> / <code>release()</code> / <code>post()</code>: <ul><li><code>sem += 1</code>;</li><li>如果存在阻塞在该信号量上的线程，选择一个唤醒。</li></ul></li></ul><h3 id="_4-死锁" tabindex="-1"><a class="header-anchor" href="#_4-死锁" aria-hidden="true">#</a> 4 死锁</h3><h4 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h4><p>多个线程形成一个等待环：所有线程都在等待其他线程的某个动作.</p><p>死锁的多种情况：</p><ul><li>自死锁（A-A型）：在已经持有某把锁的情况下再次尝试获取该锁。</li><li>互锁（ABBA型）：线程1拿到了锁A，需要获取锁B；线程2拿到了锁B，需要获取锁A。</li></ul><p>死锁的必要条件：</p><ul><li>需要的资源互斥 <ul><li>无锁算法（RCU，...）</li></ul></li><li>持有某些资源并需要更多的资源（持有-等待） <ul><li>一开始就获取所有锁 <ul><li>降低并发</li></ul></li><li>如果无法获取所有的锁，释放已经获取的锁</li></ul></li><li>不能直接抢夺其他线程的资源（非抢占性） <ul><li>直接抢占</li></ul></li><li>循环等待 <ul><li>规定申请锁的顺序</li><li>（构造一个有向无环图）</li></ul></li></ul><h4 id="银行家算法" tabindex="-1"><a class="header-anchor" href="#银行家算法" aria-hidden="true">#</a> 银行家算法</h4><p>银行家算法的关键思想是判断 <strong>未来是否可以满足</strong>。</p><ul><li>1 选择一个线程，判断其未来额外需要的最大资源数能否被系统当前持有的资源满足 <ul><li>如果所有线程都无法达成满足，则陷入死锁条件（不可挽回）</li></ul></li><li>2 对上述满足需求的线程，标注为未来可满足状态（存在某种分配方式可以分配足够其运行的资源——这些资源在它运行结束之后会被回收）；这样的线程是 <strong>能够终止的</strong>。</li><li>3 重复2，直到所有线程都能够终止为止；这说明存在一个分配方案，使得批准该资源申请之后所有线程的申请需求都能被满足。</li></ul><p><strong>不够实用</strong>：一般无法知道线程生命周期中的“最大需求”。</p><h4 id="死锁的动态检测" tabindex="-1"><a class="header-anchor" href="#死锁的动态检测" aria-hidden="true">#</a> 死锁的动态检测</h4>`,46),p=l("p",null,[a("每次锁的acquire/release都记录 tid 和 lock name，动态构建锁的有向图"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"G"),l("mo",{stretchy:"false"},"("),l("mi",null,"V"),l("mo",{separator:"true"},","),l("mi",null,"R"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"G(V, R)")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal"},"G"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),l("span",{class:"mpunct"},","),l("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R"),l("span",{class:"mclose"},")")])])]),a("，并assert该图没有环")],-1),o=l("ul",null,[l("li",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"V")]),l("annotation",{encoding:"application/x-tex"},"V")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])]),a("：每把锁的名字")]),l("li",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"E")]),l("annotation",{encoding:"application/x-tex"},"E")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E")])])]),a("：每个线程持有某把锁"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"u")]),l("annotation",{encoding:"application/x-tex"},"u")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal"},"u")])])]),a("之后再去尝试获得某把锁"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v")])])]),a("，就加入边"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"u"),l("mo",{separator:"true"},","),l("mi",null,"v"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(u, v)")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal"},"u"),l("span",{class:"mpunct"},","),l("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),l("span",{class:"mclose"},")")])])])]),l("li",null,"锁的名字可以用地址来唯一绑定，也可以是锁所在的文件和行。")],-1),d=s('<h3 id="_5-进程" tabindex="-1"><a class="header-anchor" href="#_5-进程" aria-hidden="true">#</a> 5 进程</h3><p>拥有独立空间的运行实体，可以包含一个或多个线程。</p><p>需要元信息来描述、管理进程（进程控制块，由内核维护）。</p><h4 id="进程的生命周期" tabindex="-1"><a class="header-anchor" href="#进程的生命周期" aria-hidden="true">#</a> 进程的生命周期</h4><p>进程终止后资源会被操作系统回收，并且会通知父进程它的终止状态（防止父进程PCB指针指向一块被释放的内存）。</p><p>已经终止但PCB信息还没有被回收的进程称为 <strong>僵尸进程</strong>。</p><p>父进程对于某个子进程调用wait将会阻塞父进程本身，在子进程运行结束后将退出通知返回给父进程。</p><p>如果父进程在子进程结束之前结束，子进程会变成孤儿进程；它们随后会被<code>init</code>进程接管。</p><h4 id="fork" tabindex="-1"><a class="header-anchor" href="#fork" aria-hidden="true">#</a> fork</h4><p><code>fork</code>系统调用会立即复制一份当前进程（内存和寄存器现场）作为子进程。</p><p><code>fork</code>在子进程中会返回0，在父进程中会返回子进程的进程id；出错则会返回-1.</p><p>注意：</p><ul><li>fork还会复制原进程PCB中的对象，如 <strong>打开的文件描述符</strong> 等。</li><li>多线程进程fork时只会复制 <strong>调用fork的线程</strong>。</li><li>fork并不会复制父进程的一切属性：只读内存（共享代码库、代码段）等不需要复制，由<strong>页表</strong>和父进程共享一片相同的只读内存。</li><li>现在的fork应用了 <strong>写时拷贝</strong> （允许多个进程共享同一片内存区域，当有个进程试图写入该区域时，拷贝一份副本给该进程）。</li></ul><div class="hint-container info"><p class="hint-container-title">文件描述符</p><p>文件描述符是一个指向操作系统内部对象的“指针”（并非真正的指针）。</p><p>它从0开始编号（0 = stdin, 1 = stdout, 2 = stderr）.</p><p>文件描述符有如下三种操作：</p><ul><li>open：打开文件，返回文件描述符</li><li>close：关闭文件，释放文件描述符</li><li>dup：复制文件描述符（多一个访问）</li></ul><p>文件描述符能够记忆上次访问到文件中的位置。</p></div><h4 id="exec" tabindex="-1"><a class="header-anchor" href="#exec" aria-hidden="true">#</a> exec</h4><p>exec系列系统调用可以将当前进程所运行的程序 <strong>替换</strong> 为一个执行的新程序，并重置栈、堆和PCB中的memory mapping。</p><p><code>int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[])</code></p><ul><li><code>pathname</code>:新程序的路径</li><li><code>argv</code>:传递给新程序的命令行参数</li><li><code>envp</code>:传递给新程序的环境参数(xx=a, yy=b)，用NULL截断。</li></ul><h4 id="exit" tabindex="-1"><a class="header-anchor" href="#exit" aria-hidden="true">#</a> exit</h4><p>在linux中，进程有五种退出机制：</p><ul><li>正常退出 <ul><li>从<code>main()</code>返回</li><li>调用<code>exit()</code><ul><li>会进行清理（关闭所有打开的流、移除临时文件、调用<code>atexit()</code>注册的函数）</li></ul></li><li>调用<code>_exit()</code>（不会进行清理，线程不安全） <ul><li>关闭该进程的所有文件描述符</li><li>将所有子进程交由<code>init</code>接管</li><li>向父进程发送<code>SIGCHLD</code>信号。</li></ul></li></ul></li><li>异常退出 <ul><li>调用<code>abort()</code>（发送<code>SIGABRT</code>）</li><li>信号终止（<code>SIGSEGV</code>, ...） <ul><li>使用<code>signal()</code>函数可以注册信号处理函数。</li></ul></li></ul></li></ul><h3 id="_6-调度" tabindex="-1"><a class="header-anchor" href="#_6-调度" aria-hidden="true">#</a> 6 调度</h3><p>调度是为了满足既定目标，对计算任务进行资源分配的行为。</p><p>调度指标：</p><ul><li>CPU利用率：CPU被进程使用的时间 / 所有CPU时间； <strong>越大越好</strong>。</li><li>公平：同等优先级的进程获得的CPU使用时间应该相等。</li><li>吞吐量：单位时间内完成执行的进程数；<strong>越大越好</strong>。</li><li>周转时间：某个进程需要完成的时间；<strong>越小越好</strong></li><li>等待时间：某个进程在就绪队列，等待被执行的时间；<strong>越小越好</strong>。 <ul><li>等待时间 = 周转时间 - 在CPU上执行的时间。</li><li>进程可能会多次进入就绪队列中。</li></ul></li><li>响应时间：从发出申请执行 到 <strong>第一次</strong>获得响应执行的时间； <strong>越小越好</strong>。</li></ul><p>调度的目的是让CPU重新回到操作系统的掌控之中——</p><ul><li>发生系统调用（<code>fork</code>,<code>exit</code>等）</li><li>某个进程阻塞（wait子进程，等待IO完成，...）</li><li>发生中断（IO中断、时钟终端、...）</li></ul><div class="hint-container info"><p class="hint-container-title">机制和策略</p><p>在系统设计中，有一个重要的设计思想：<strong>机制和策略分离</strong>。</p><ul><li>策略 表示系统 “<strong>可以做什么</strong>”。</li><li>机制 表示系统 “<strong>应该如何做</strong>”。</li></ul><p>在已有的机制上可以思考“该机制可以满足的策略中，哪个策略最优？”</p><p>在已有的策略下可以思考“实现该策略需要怎样的机制？”</p></div><p>调度的任务大致可以分为以下几类：</p><ul><li>批处理任务的调度</li><li>交互性任务的调度</li><li>实时任务的调度</li></ul><h4 id="批处理任务的调度" tabindex="-1"><a class="header-anchor" href="#批处理任务的调度" aria-hidden="true">#</a> 批处理任务的调度</h4><p>FCFS: 先来先服务</p><ul><li>按照进程就绪的顺序进行调度</li><li>会导致 <strong>护航效应</strong><ul><li>护航效应：短运行时间的进程排在长运行时间进程的后面，导致平均等待时间过长。</li></ul></li></ul><h4 id="交互性任务的调度" tabindex="-1"><a class="header-anchor" href="#交互性任务的调度" aria-hidden="true">#</a> 交互性任务的调度</h4><div class="hint-container info"><p class="hint-container-title">计算密集型任务 / IO密集型任务</p><p>在调度中，两类任务会被特殊对待：</p><ul><li>计算密集型任务 <ul><li>需要消耗大量CPU资源，但很少需要等待外部任务（磁盘、网络通信等）完成</li></ul></li><li>IO密集型任务 <ul><li>大部分时间都在等待IO（键盘、硬盘、内存、...），在此期间消耗的CPU计算时间很少。</li></ul></li></ul></div><h5 id="时间片轮转调度-round-robin" tabindex="-1"><a class="header-anchor" href="#时间片轮转调度-round-robin" aria-hidden="true">#</a> <strong>时间片轮转调度</strong>（Round-Robin）</h5><ul><li>每个任务都会获得一段固定时间的资源。</li><li>如果该任务在这段时间资源内没有完成，将重新回到任务队列中。</li><li>时间片应该比上下文切换时间大；一般为10ms~100ms。</li><li>平均周转时间较长，overhead（多余开销较大）。</li></ul><p>RR还存在一个问题：当同时运行IO密集型任务（如文字处理）和计算密集型任务（如渲染、模拟）时，IO密集型任务执行IO操作时会让出CPU；然而IO程序在让出后，即便IO任务很快完成，也必须等待操作系统重新为它分配处理器（等待计算密集型任务用完完整的CPU时间切片）。</p><p>为了解决该问题，我们需要 <strong>基于优先级的调度</strong>。</p><h5 id="基于优先级的调度" tabindex="-1"><a class="header-anchor" href="#基于优先级的调度" aria-hidden="true">#</a> <strong>基于优先级的调度</strong></h5><ul><li>每个进程都关联于一个优先级数。</li><li>每次发生调度时，将CPU分配给具有最高优先级的进程。</li></ul><p>linux下默认的优先级：</p><ul><li>实时任务：高优先级(0~99)</li><li>普通任务：低优先级(100~139)</li></ul><div class="hint-container info"><p class="hint-container-title">老化</p><p>饿死：低优先级的进程可能永远不会执行。</p><p>解决方案：老化（随着时间的推移增加进程的优先级）。</p></div><h5 id="多级反馈队列-mfq" tabindex="-1"><a class="header-anchor" href="#多级反馈队列-mfq" aria-hidden="true">#</a> 多级反馈队列 (MFQ)</h5><ul><li>一个进程可以在各个队列（代表不同的优先级）之间移动。</li><li>调度器由以下参数定义： <ul><li>队列数量</li><li>每个队列的调度算法（对不同优先级采用不同的调度办法）</li><li>确定何时提升进程优先级、何时降低进程优先级的算法</li><li>确认某个进程需要服务时进入哪个队列的算法</li></ul></li></ul><p>例：一个典型的多级反馈队列</p><ul><li>队列：一组轮转队列，每个队列有不同的优先级。 <ul><li>高优先级队列拥有较短的时间片（调度更精细），反之时间片较长。</li></ul></li><li>调度器优先选择优先级最高队列中的第一个进程。</li><li>进程载入内存时初始在最高优先级队列中。</li><li>如果时间片到期，进程会降低一个级别。</li></ul><p>在这种调度方法下，</p><ul><li>CPU密集型进程将下沉到时间片较长的队列——较大的时间片可以减少上下文切换的开销。</li><li>IO密集型进程将保持在高优先级队列中（当它进行IO操作时不足以用完自身的CPU时间片，因此会保持在原位）</li><li>仍然存在饥饿问题 <ul><li>如果频繁创建新进程 / 有大量交互式进程，则低优先级很少会被调度。</li></ul></li><li>一个交互式进程可能时钟会在低优先级水平（如大型游戏等）。</li></ul><h4 id="多核cpu调度" tabindex="-1"><a class="header-anchor" href="#多核cpu调度" aria-hidden="true">#</a> 多核CPU调度</h4><p>在多核心系统中，有两种调度方法：</p><ul><li>单个处理器（主服务器）处理所有调度决策，其他处理器执行用户代码 <ul><li>实现简单</li><li>主服务器成为可能的性能瓶颈</li></ul></li><li>对称多处理（SMP） <ul><li>有两种队列机制： <ul><li>多个CPU共享一个统一的调度队列 （有锁，低效）</li><li>每个CPU维护自身的调度队列（常用）</li></ul></li><li>有两种负载均衡的方式： <ul><li>推迁移（周期性检查每个处理器的负载，过载则将任务推送至其他核心）</li><li>拉迁移（空闲处理器从繁忙处理器队列中拉取等待的任务）</li></ul></li><li>负载均衡可能会破坏 <strong>处理器亲和性</strong> （该处理器的缓存存储了该线程的内存访问）。</li></ul></li></ul><h4 id="优先级反转问题" tabindex="-1"><a class="header-anchor" href="#优先级反转问题" aria-hidden="true">#</a> 优先级反转问题</h4><p>假设系统此时有两个线程: T1（低优先级，已准备好）和 T2（高优先级，还未准备好）。</p><p>此时，操作系统会首先调度 T1 运行。假设此时 T1 获取了一个自旋锁并进入了临界区。</p><p>当 T2 准备就绪时，调度器立即调度 T2 取代 T1 运行。</p><p>然而 T2 需要获取同一把自旋锁，因此开始忙碌等待；但由于 T2 运行时 T1 不会被调度，因此 T1 无法离开临界区，T2 也无法继续运行。</p><p>在这种情况下，一个高优先级任务反而受制于一个低优先级任务而无法运行。</p><p>优先级反转问题的解决方案之一是 <strong>优先权极限和优先级继承</strong>。</p><h4 id="优先权极限、优先权继承" tabindex="-1"><a class="header-anchor" href="#优先权极限、优先权继承" aria-hidden="true">#</a> 优先权极限、优先权继承</h4><p>优先权极限：当一个任务获取一把锁时，该任务的优先级将被提升至 和该锁关联的 优先级上限。</p><p>优先权继承：当一个任务持有一把锁时，如果其他更高优先级的任务试图获取该锁，则持有锁的任务的优先级会被提升到 该更高优先级任务的 优先级。</p><h3 id="_7-内存管理" tabindex="-1"><a class="header-anchor" href="#_7-内存管理" aria-hidden="true">#</a> 7 内存管理</h3><h4 id="虚拟内存、虚拟地址" tabindex="-1"><a class="header-anchor" href="#虚拟内存、虚拟地址" aria-hidden="true">#</a> 虚拟内存、虚拟地址</h4><ul><li>虚拟内存使得应用程序不再直接访问物理内存，而是使用虚拟地址访问主存；</li><li>应用使用虚拟地址访问时，虚拟地址会自动被硬件翻译为物理地址。</li><li>每个应用都有独立的虚拟地址内存空间；应用认为自己独占这一片内存空间。</li><li>进程被映射到的物理地址可以在运行时不断变化（动态重定位）。</li><li>进程之间可以进行数据共享（将不同进程的不同虚拟地址映射到同一片物理地址）</li><li>虚拟地址还可以构建一个“连续空间”的假象，即虚拟内存在应用程序看来是连续的，但在物理内存上可能不是连续的。</li></ul><p>连续内存分配有两种策略：</p><ul><li>固定分区 <ul><li>不适用于需要空间很大的进程</li><li>会产生内部碎片</li></ul></li><li>可变分区 <ul><li>会产生外部碎片（分散的小片内存空间导致的内存浪费，通常由于进程不断加载、释放所致） <ul><li>可以将进程终止 / 暂时交换出磁盘，以释放内存，合并形成大的空间区域</li><li>可以紧缩（重排内存内容），但时间复杂度较高</li></ul></li><li>会产生内部碎片（较轻）</li></ul></li></ul><h4 id="分段-用户视角的内存管理" tabindex="-1"><a class="header-anchor" href="#分段-用户视角的内存管理" aria-hidden="true">#</a> 分段（用户视角的内存管理）</h4><p>分段机制将程序视为一组段（segment）。</p><p>段是虚拟内存空间的连续区域，也是一个逻辑单元（代码段、栈、堆、...）；按照段来分配内存。</p><p>在分段机制中，每个段独立的映射到物理内存中的一组连续地址；</p><ul><li>没有特定顺序</li><li>不需要映射未使用的地址（消除了内部碎片）</li><li>不同的段可以独立变化</li></ul><p>在分段机制中，每个进程都有一个段表，用来存储每个分段的信息。</p><p>段表中包含：</p><ul><li>段基址（段的起始物理地址）</li><li>段界限（端的大小）</li></ul><p>在分段机制中，虚拟地址分为 段号 + 段内地址（偏移）。</p><p>段表中还包含 <strong>保护位</strong>：指示程序是否有该段的读/写/执行权限。</p><h4 id="分页-更细粒度的内存管理" tabindex="-1"><a class="header-anchor" href="#分页-更细粒度的内存管理" aria-hidden="true">#</a> 分页（更细粒度的内存管理）</h4><p>在分页机制中：</p><ul><li>物理内存被划分成连续等长的物理页（帧）。</li><li>虚拟内存也会被划分为大小相同的虚拟块（虚拟页）。</li><li>任意一个虚拟页可以被映射到任意一个物理页。</li><li>因为按照分页来分配内存，所有没有外部碎片。</li></ul><p>分页机制中的虚拟地址：</p><p>分为 <strong>虚拟页号</strong> 和 <strong>页内偏移</strong>。</p><p>每个进程都有一个 <strong>页表</strong>，<strong>每个页表项</strong> 都包含一个 <strong>物理页号</strong>，用来指示每个页在物理内存中的基地址。</p><p>多级页表：将页表划分为多层，如果某级页表中的条目为空，则下一级页表无需存在。</p><h4 id="tlb-地址转换旁路缓冲" tabindex="-1"><a class="header-anchor" href="#tlb-地址转换旁路缓冲" aria-hidden="true">#</a> TLB / 地址转换旁路缓冲</h4><p>我们利用<strong>局部性原理</strong>，通过TLB来加速分页的地址转换。</p><p>TLB会缓存最近的地址转换。</p><p>如果需要转换的地址在TLB中存在，则直接应用转换；如果TLB未命中，则在页表中查找映射，并更新TLB。</p><p>一个典型的TLB缓存项包含：</p><ul><li>虚拟页号和对应的帧号</li><li>有效位（转换是否有效） <ul><li>该“有效”和页表项中的“有效”意义不同：页表项中的有效指的是页本身是否有效，而TLB中的有效指的是转换是否正确。</li></ul></li><li>保护位（访问权限控制）</li><li>修改位：页面是否被修改</li></ul><div class="hint-container info"><p class="hint-container-title">局部性原理</p><p>局部性原理是指指令和数据引用的局部性。</p><ul><li>时间局部性：如果某个数据被访问过，则不久的将来它可能会再次被访问</li><li>空间局部性：如果某个数据被访问过，则附近的数据在不久的将来也可能会被访问</li></ul></div>',92),u=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"有效访问时间、命中率"),l("p",null,[a("如果已知TLB命中率"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"α")]),l("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a(", 内存访问时间"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"t")]),l("annotation",{encoding:"application/x-tex"},"t")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6151em"}}),l("span",{class:"mord mathnormal"},"t")])])]),a(",TLB查找时间"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"ϵ")]),l("annotation",{encoding:"application/x-tex"},"\\epsilon")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal"},"ϵ")])])]),a("，则有")]),l("p",{class:"katex-block"},[l("span",{class:"katex-display"},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mtext",null,"有效访问时间"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"A"),l("mi",null,"T"),l("mo",{stretchy:"false"},")"),l("mo",null,"="),l("mo",{stretchy:"false"},"("),l("mi",null,"ϵ"),l("mo",null,"+"),l("mi",null,"t"),l("mo",{stretchy:"false"},")"),l("mi",null,"α"),l("mo",null,"+"),l("mo",{stretchy:"false"},"("),l("mi",null,"ϵ"),l("mo",null,"+"),l("mn",null,"2"),l("mi",null,"t"),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},"("),l("mn",null,"1"),l("mo",null,"−"),l("mi",null,"α"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"}," \\text{有效访问时间}(EAT) = (\\epsilon + t) \\alpha + (\\epsilon + 2t)(1 - \\alpha) ")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord text"},[l("span",{class:"mord cjk_fallback"},"有效访问时间")]),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),l("span",{class:"mord mathnormal"},"A"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"mclose"},")"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal"},"ϵ"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal"},"t"),l("span",{class:"mclose"},")"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal"},"ϵ"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord"},"2"),l("span",{class:"mord mathnormal"},"t"),l("span",{class:"mclose"},")"),l("span",{class:"mopen"},"("),l("span",{class:"mord"},"1"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),l("span",{class:"mclose"},")")])])])])]),l("p",null,"如果TLB命中，则直接获得对应的物理地址，访存一次即可；如果TLB未命中，则需要先访问页表，再访存获取数据。")],-1),g=s('<h4 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h4><p>虚拟内存允许多个并发运行的进程使用大虚拟地址空间，但只将常用的页面保留在内存中（部分加载）。</p><p>这样可以</p><ul><li>让程序不再受物理内存限制（程序不用完全加载进内存，可以运行更大的程序）</li><li>每个程序运行时占用更少的内存，可以同时运行更多程序</li><li>加载或交换程序到内存中所需的io更少（启动更快）</li></ul><p>虚拟内存使用页表项中的存在 / 不存在位来跟踪哪些页面存在于物理内存中。</p><p>如果程序引用的页面在物理内存中，则直接进行地址转换；如果不在，则发生缺页异常，调用操作系统处理异常。</p><p>过程：</p><ul><li>硬件陷入内核，进行上下文切换</li><li>系统尝试确定所需的虚拟页面</li><li>确定引发异常的虚拟地址，检查地址是否有效、是否有权限访问</li><li>找到一个空闲帧 <ul><li>如果没有，则运行页面置换，将一个页面置换至硬盘 / ...</li><li>如果所选帧是脏的，则将页面安排转移至磁盘，进行上下文切换，<strong>暂停引发异常的进程（来等待修改写回磁盘）</strong>。</li></ul></li><li>系统查找所需页面的磁盘地址，并安排磁盘操作将其调入</li><li>当磁盘中断指示页面到达时，更新页表并将帧标记为正常状态</li><li>将引发缺页异常的指令恢复，并重置程序计数器</li><li>调度引发缺页异常的进程，进行上下文切换</li></ul><p>处理缺页异常主要有三个活动：</p><ul><li>服务中断 几百条指令</li><li>读取页面 大量时间</li><li>恢复进程 少量时间</li></ul><p>缺页错误率：进程在内存中发现缺页异常的比率</p>',11),x=l("p",null,[a("有效访问时间"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"E"),l("mi",null,"A"),l("mi",null,"T")]),l("annotation",{encoding:"application/x-tex"},"EAT")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),l("span",{class:"mord mathnormal"},"A"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T")])])]),a(": "),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"E"),l("mi",null,"A"),l("mi",null,"T"),l("mo",null,"="),l("mo",{stretchy:"false"},"("),l("mn",null,"1"),l("mo",null,"−"),l("mi",null,"p"),l("mo",{stretchy:"false"},")"),l("mo",null,"×"),l("mtext",null,"访存时间"),l("mo",null,"+"),l("mi",null,"p"),l("mo",null,"×"),l("mtext",null,"缺页异常开销")]),l("annotation",{encoding:"application/x-tex"},"EAT = (1 - p) \\times \\text{访存时间} + p \\times \\text{缺页异常开销}")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),l("span",{class:"mord mathnormal"},"A"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mopen"},"("),l("span",{class:"mord"},"1"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal"},"p"),l("span",{class:"mclose"},")"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"×"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),l("span",{class:"mord text"},[l("span",{class:"mord cjk_fallback"},"访存时间")]),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.1944em"}}),l("span",{class:"mord mathnormal"},"p"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"×"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord text"},[l("span",{class:"mord cjk_fallback"},"缺页异常开销")])])])])],-1),b=s('<h4 id="页面替换" tabindex="-1"><a class="header-anchor" href="#页面替换" aria-hidden="true">#</a> 页面替换</h4><p>当一个页面需要被换出时，需要：</p><ul><li>更新页表：找到所有引用旧页面的页表项，并将其标记为不可见。</li><li>移除所有TLB条目 <ul><li>TLB关机：在多处理器系统中，必须从所有处理器的TLB中消除条目。</li></ul></li><li>将页面写回磁盘(如果脏位为1的话)</li><li>重新启动引发陷阱的指令.</li></ul><p>页面也可以被锁定（固定在内存中）。</p><p>操作系统中还存在页面buffering：保留一组空闲帧，以便于在需要的时候总有可用的帧。</p><div class="hint-container note"><p class="hint-container-title">页面替换策略</p><p>页面替换策略有如下几种：</p><ul><li>FIFO：使用FIFO队列来跟踪页面的老化程度，并替换最老的页面 <ul><li>Belady异常：增加帧数可能会导致命中率下降 <ul><li>会发生在不遵守栈算法属性（先前存在的页面应该总是保留在内存中）的任何页面替换算法中。</li></ul></li></ul></li><li>Optimal：替换在最长时间内不会被使用的页面 <ul><li>（理想情况，不存在实现）</li></ul></li><li>LRU：替换那些在最长时间内没有被使用的页面 <ul><li>基于局部性原理 <ul><li>每个页面都有一个计数器项</li><li>每次页面被引用时，将时钟寄存器的值复制到寄存器中。</li><li>需要更换页面时，查找最小的值。</li></ul></li><li>开销较大</li></ul></li><li>近似LRU：寻找一个在最近的时钟周期内没有被引用的老页面。 <ul><li>系统中每个页面都存在一个引用位（R）；每当页面被读取 / 写入时，将引用位置为1.</li><li>如果要被替换的页面R为1，则将引用位设置为0，并将其放置在FIFO队列的末尾，检查下一个页面</li><li>如果要被替换的页面R为0，则直接替换。</li></ul></li><li>二次机会算法（时钟算法）： <ul><li>将所有页面帧以时钟形式放置在循环列表中。</li><li>当发生缺页异常时，检查当前指向的页面： <ul><li>如果该页面的R = 0，则直接替换</li><li>如果该页面的R = 1，则将R - 1并将指针向前移。</li></ul></li><li>另一种变体是N次机会算法（为每个页面增加一个扫描次数计数器，如果扫描次数等于N就替换）</li></ul></li><li>NRU：通过两个状态位（引用位，修改位）来近似LRU，为那些被修改过的页面赋予更高的优先级来减少IO负担。 <ul><li>(0, 0)：最近未使用过，未修改过（最适合替换）</li><li>(0, 1)：最近未使用过，但修改过；替换前需要写入磁盘</li><li>(1, 0)：最近使用过但未修改过（可能会被再次使用）</li><li>(1, 1)：最近使用过且修改过(可能会被再次使用，且需要在替换前写入磁盘)</li><li>从最低编号的非空类中随机移除一个页面。</li></ul></li><li>老化算法：保持一个软件计数器来追踪每个页面被引用的次数，并替换引用次数最小的页面 <ul><li>在每个时钟中断时，将每个页面的计数器右移一位，并将R位添加到最左侧。</li><li>计数器较大的值表示该页面最近使用过。</li></ul></li></ul><div class="hint-container note"><p class="hint-container-title">抖动（Thrashing）</p><p>如果一个进程没有足够的页面可用，则缺页率可能极高；此时大部分CPU时间都会被用来处理缺页异常，仅有小部分时间会用于执行真正有意义的工作。</p><p>此外，调度器还会进一步使问题加剧：缺页率高 -&gt; CPU利用率低 -&gt; 载入更多进程来提高利用率 -&gt; 页面更加不足。</p></div></div><h3 id="_8-设备管理" tabindex="-1"><a class="header-anchor" href="#_8-设备管理" aria-hidden="true">#</a> 8 设备管理</h3><p>IO设备大体可以分为：</p><ul><li>块设备（以块为单位存储、传输信息）</li><li>字符设备（传递 / 接收字符流，不可寻址）</li></ul><p>设备有两个重要组成部分：</p><ul><li>向系统其他部分呈现的硬件接口 <ul><li>由几个寄存器组成（状态寄存器、命令寄存器、...）</li></ul></li><li>内部结构（具体实现）</li></ul><p>处理器能以两种方式访问设备的寄存器：</p><ul><li>端口映射 <ul><li>额外的IO指令：每个控制寄存器都有一个独特的IO端口号</li></ul></li><li>内存映射 <ul><li>将控制寄存器映射到内存空间中</li><li><strong>控制寄存器的内存映射应该禁用缓存！</strong></li></ul></li></ul><p>操作系统能以两种方式获取设备的信息：</p><ul><li>轮询 <ul><li>开销低，但会浪费CPU周期</li></ul></li><li>IO中断 <ul><li>不会浪费CPU周期，但开销高（切换上下文）</li></ul></li></ul><p>数据传输命令的控制：</p><ul><li>CPU控制 <ul><li>硬件简单，易于编程</li><li>CPU开销高</li></ul></li><li>直接内存访问（DMA） <ul><li>给与DMA设备访问内存和总线的权限.</li><li>DMA传输完成后会用中断通知CPU。</li></ul></li></ul><h4 id="驱动程序" tabindex="-1"><a class="header-anchor" href="#驱动程序" aria-hidden="true">#</a> 驱动程序</h4><p>驱动程序指的是用来管理IO设备的代码。</p><p>驱动程序一般分为两部分：</p><ul><li>上半部分：在系统的调用路径中访问 <ul><li>实现一组标准的、跨设备的接口</li><li>启动设备的IO操作，然后休眠</li></ul></li><li>下半部分：作为中断例程运行 <ul><li>获取输入 / 传输下一块输出</li><li>完成IO后唤醒休眠的线程</li></ul></li></ul><h4 id="磁盘原理" tabindex="-1"><a class="header-anchor" href="#磁盘原理" aria-hidden="true">#</a> 磁盘原理</h4><p>磁盘的每个盘片分为数个磁道，每个磁道又分为不同数量的扇区。</p><p>在访问磁盘时，首先要确定启用哪个磁头（哪张盘片）；然后将磁头移动到对应的磁道上（寻道），等待盘片旋转至一定位置（旋转），然后进行传输。</p>',24),y=l("p",null,[a("磁盘访问时间："),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"T"),l("mrow",null,[l("mi",null,"d"),l("mi",null,"i"),l("mi",null,"s"),l("mi",null,"k")])]),l("mo",null,"="),l("msub",null,[l("mi",null,"T"),l("mrow",null,[l("mi",null,"s"),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"k")])]),l("mo",null,"+"),l("msub",null,[l("mi",null,"T"),l("mrow",null,[l("mi",null,"r"),l("mi",null,"o"),l("mi",null,"t"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"i"),l("mi",null,"o"),l("mi",null,"n")])]),l("mo",null,"+"),l("msub",null,[l("mi",null,"T"),l("mrow",null,[l("mi",null,"t"),l("mi",null,"r"),l("mi",null,"a"),l("mi",null,"n"),l("mi",null,"s"),l("mi",null,"f"),l("mi",null,"e"),l("mi",null,"r")])])]),l("annotation",{encoding:"application/x-tex"},"T_{disk} = T_{seek} + T_{rotation} + T_{transfer}")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord"},[l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3361em"}},[l("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mathnormal mtight"},"d"),l("span",{class:"mord mathnormal mtight"},"i"),l("span",{class:"mord mathnormal mtight"},"s"),l("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])]),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord"},[l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3361em"}},[l("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mathnormal mtight"},"see"),l("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])]),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord"},[l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3117em"}},[l("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mathnormal mtight"},"ro"),l("span",{class:"mord mathnormal mtight"},"t"),l("span",{class:"mord mathnormal mtight"},"a"),l("span",{class:"mord mathnormal mtight"},"t"),l("span",{class:"mord mathnormal mtight"},"i"),l("span",{class:"mord mathnormal mtight"},"o"),l("span",{class:"mord mathnormal mtight"},"n")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])]),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.9694em","vertical-align":"-0.2861em"}}),l("span",{class:"mord"},[l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3361em"}},[l("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mathnormal mtight"},"t"),l("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.02778em"}},"r"),l("span",{class:"mord mathnormal mtight"},"an"),l("span",{class:"mord mathnormal mtight"},"s"),l("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.10764em"}},"f"),l("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.02778em"}},"er")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.2861em"}},[l("span")])])])])])])])])],-1),v=s('<h4 id="磁头调度" tabindex="-1"><a class="header-anchor" href="#磁头调度" aria-hidden="true">#</a> 磁头调度</h4><ul><li>FCFS：先到先服务 <ul><li>请求之间是公平的</li><li>请求会按照应用程序预期的顺序完成</li><li>寻道时间较长（到达的位置可能会在随机的磁道上）</li></ul></li><li>SSTF：最短寻道时间优先 <ul><li>按照磁道顺序排列IO请求</li><li>最小化寻道时间</li><li>可能会导致饿死（一直有某个磁道上的请求，其他请求无法得到服务）</li></ul></li><li>SCAN：电梯算法 <ul><li>简单的在磁盘上来回移动，按顺序跨磁道处理请求</li><li>有多种变体： <ul><li>F-SCAN：在执行扫描时冻结要处理的队列（防止远距离饿死）</li><li>C-SCAN：只从外向内扫描</li></ul></li></ul></li><li>SPTF：最短重定位时间优先 <ul><li>同时考虑寻道时间和旋转时间。</li></ul></li></ul><h3 id="_9-文件系统" tabindex="-1"><a class="header-anchor" href="#_9-文件系统" aria-hidden="true">#</a> 9 文件系统</h3><p>文件系统会将文件元数据保留在文件控制块中，存储在磁盘上，并缓存在内存中。</p><p>在unix系统下，这个文件控制块就是inode（index node）。</p><h4 id="硬链接" tabindex="-1"><a class="header-anchor" href="#硬链接" aria-hidden="true">#</a> 硬链接</h4><p>在当前目录下创建另一个名称，并将其指向原始文件的相同inode号。</p><ul><li>只能连接到同一个系统上的文件（inode唯一的范围为本系统）。</li><li>不允许链接到目录 <ul><li>防止循环</li><li>避免父目录不明确</li></ul></li></ul><h4 id="软链接" tabindex="-1"><a class="header-anchor" href="#软链接" aria-hidden="true">#</a> 软链接</h4><p>创建一种不同类型的文件（是路径名的别名）。</p><ul><li>当需要解析路径名时解析符号链接。</li><li>效率较低</li><li>当目标文件被删除时，会产生 <strong>引用悬空</strong>。</li></ul><h4 id="inode的多级索引" tabindex="-1"><a class="header-anchor" href="#inode的多级索引" aria-hidden="true">#</a> inode的多级索引</h4><p>为每个文件分配一个 <strong>指针数组块</strong>（索引块），该块中存储了 <strong>指向文件数据块</strong> 的一系列指针。</p><p>当文件打开时，加载该指针数组块进入内存。</p><p>可以将索引块中的指针指向另一个由指针数组块，从而实现inode的多级索引。</p><p>一般会存在2~3级的非间接指针。</p><h4 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h4><p>为保证文件系统的稳定性，一般会采取预写日志(write-ahead logging) / 日志(journaling)。</p><ul><li>在覆盖文件结构之前，先向磁盘上写一个小日志来描述要做的事情</li><li>如果在更新中出现问题，可以重启读取日志并重试</li><li>一旦事务安全的写入磁盘，将更新内容写入日志最终的磁盘位置</li></ul><p>当需要从崩溃中恢复时，文件系统会扫描日志并查找已提交的事务。</p><ul><li>如果在日志提交前发生崩溃，则忽略待处理的更新</li><li>如果在日志提交之后、检查点之前发生崩溃，则按顺序重放已提交的事务（重做日志）。</li></ul>',21),f=[r,m,c,h,p,o,d,u,g,x,b,y,v];function w(k,_){return e(),n("div",null,f)}const L=i(t,[["render",w],["__file","os_notes.html.vue"]]);export{L as default};
