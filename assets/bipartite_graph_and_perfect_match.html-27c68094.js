import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as h,o as t,c as i,d as n,a as e,b as d,f as a,e as o}from"./app-ed27b45a.js";const l={},p=e("h1",{id:"离散数学复习-二部图与匹配",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#离散数学复习-二部图与匹配","aria-hidden":"true"},"#"),d(" 离散数学复习：二部图与匹配")],-1),s=e("p",null,[e("s",null,"寄寄寄寄摆摆摆摆")],-1),u=o('<h2 id="二部图" tabindex="-1"><a class="header-anchor" href="#二部图" aria-hidden="true">#</a> 二部图</h2><h3 id="二部图-定义" tabindex="-1"><a class="header-anchor" href="#二部图-定义" aria-hidden="true">#</a> 二部图：定义</h3><p>可以将顶点集划分为两个不相交的类别、每一条边的两个端点都在不同类别中的图。</p><h3 id="完全二部图" tabindex="-1"><a class="header-anchor" href="#完全二部图" aria-hidden="true">#</a> 完全二部图</h3><p>来自不同类别的任意两个顶点之间均有边相连。</p><h2 id="图中的匹配" tabindex="-1"><a class="header-anchor" href="#图中的匹配" aria-hidden="true">#</a> 图中的匹配</h2><ul><li>匹配：一张图中互不相邻的边的集合，记为<code>M</code>。</li><li>M-饱和点：<code>M</code>中各点的端点。</li></ul><h3 id="二部图中的完备匹配" tabindex="-1"><a class="header-anchor" href="#二部图中的完备匹配" aria-hidden="true">#</a> 二部图中的完备匹配</h3><p><strong>定义</strong>：设<code>G</code>为二部图且可被二部划分为<code>&lt;V1, V2&gt;</code>, 若<code>G</code>中的匹配<code>M</code>能够饱和<code>V1</code>中所有的顶点，则称<code>M</code>是 <strong><code>V1</code>到<code>V2</code>的</strong> 完备匹配`（<strong>不是完美匹配！</strong>）</p><p><em>注：完备匹配一定是最大匹配，但当且仅当<code>|V1| = |V2|</code>时该匹配才能被称为完美匹配。</em></p><p><em><strong>注2： 完备匹配不一定是稳定匹配，稳定匹配不一定是完备匹配！</strong></em></p><h3 id="hall定理" tabindex="-1"><a class="header-anchor" href="#hall定理" aria-hidden="true">#</a> Hall定理</h3><p>设二部图<code>G = &lt;V1, V2, E&gt;</code>， 则<code>G</code>有从V1到V2的完备匹配当且仅当对于任意<code>A ⊆ V1</code>, 有<code>|N(A)|(A的相邻顶点数) ≥ |A|</code>.</p><p>证明：</p><p>必要性显然。</p><p>充分性：</p><ol><li>当<code>|V1| == 1</code>时充分性显然成立。</li><li>假设当<code>|V1| ≤ k (k ≥ 1)</code>时充分性成立，现证明当<code>|V1| == k + 1</code>时命题也成立。<br>分成两种情况证明。</li></ol><blockquote><p>(1). 对于<code>V1</code>的任意真子集<code>A</code>，<code>|N(A)| &gt; |A|</code>:</p><p>从<code>V1</code>中任取一个顶点<code>v</code>, 从<code>M(v)</code>中任取一个顶点<code>w</code>；</p><p>则有<code>v ∈ V1, w ∈ V2</code>.</p><p>由归纳假设得，此时<code>V1 - {v} 到 V2 - {w}</code>构成一个完备匹配。</p><p>可得上述完备匹配加上边<code>(v, w)</code>可以构成从<code>V1</code>到<code>V2</code>的完备匹配。</p><br> (2). 存在`V1`的一个**真**子集`A&#39;`，`|N(A&#39;)| = |A&#39;|`. <p>记<code>B&#39; = N(A&#39;)</code>。</p><p>根据归纳假设，存在从<code>A&#39;</code>到<code>B&#39;</code>的完备匹配。又因为假设，有<code>|V2 - B&#39;| ≥ |V1 - A&#39;|</code>。</p><p>即存在从<code>V1 - A&#39;</code>到<code>V2 - B&#39;</code>的一个完备匹配。</p><p>将以上两个匹配相合并，即可得到一个<code>V1</code>到<code>V2</code>的完备匹配。</p></blockquote><h3 id="hall定理-推论" tabindex="-1"><a class="header-anchor" href="#hall定理-推论" aria-hidden="true">#</a> Hall定理：推论</h3><h4 id="正则图" tabindex="-1"><a class="header-anchor" href="#正则图" aria-hidden="true">#</a> 正则图</h4><p><em>正则图（regular graph）是指每个顶点都有相同数目的相邻顶点的图(亦即<code>对于任意v∈G, N(v) ≡ k</code>)， 称为<code>k-正则图</code>.</em></p><p><em>特别的，阶（图中的点数）为<code>K</code>的<code>K-1 - 正则图</code>即为<code>K-完全图</code></em>。</p><h4 id="推论内容" tabindex="-1"><a class="header-anchor" href="#推论内容" aria-hidden="true">#</a> 推论内容</h4><p><strong>设<em>二部图</em><code>G</code>是<code>K-正则</code>的<code>(k ≥ 1)</code>， 则<code>G</code>有<em>完美</em>匹配。</strong></p><h4 id="证明" tabindex="-1"><a class="header-anchor" href="#证明" aria-hidden="true">#</a> 证明</h4><blockquote><p>设<code>G = &lt;A, B, E&gt;</code>, 则有<code>K|A| = K|B|</code>（每个点所连接的边数相同，但所有边均存在于两组点之间），因此<code>|A|=|B|</code>.</p><p>对于任意一<strong>集合</strong><code>S ∈ A</code>, <code>S</code>与<code>N(S)</code>之间共有<code>K|S|</code>条边；但与<code>N(S)</code>相关的边共有<code>K|N(S)|</code>条。</p><p>因此有<code>K|N(S)| ≥ K|S|</code>（从<code>S</code>连接到<code>N(S)</code>的边包含在与<code>N(S)</code>有关的边之中）。 <br>因此， <code>|N(S)| ≥ |S|</code>.</p><p>由霍尔定理得，在<code>G</code>中存在从<code>A</code>到<code>B</code>的完备匹配。又因为<code>|A| = |B|</code>，所以该匹配是完美匹配。</p></blockquote><h4 id="另一个推论-更一般的情况" tabindex="-1"><a class="header-anchor" href="#另一个推论-更一般的情况" aria-hidden="true">#</a> 另一个推论（更一般的情况）</h4><p>二部图<code>G = &lt;V1, V2, E&gt;</code>, 若<code>V1</code>中每个顶点至少关联<code>t</code>条边，而若<code>V2</code>中每个顶点至多关联<code>t</code>条边，则<code>G</code>中存在<code>V1</code>到<code>V2</code>的完备匹配。</p><hr><h3 id="交错路径与可增广路径" tabindex="-1"><a class="header-anchor" href="#交错路径与可增广路径" aria-hidden="true">#</a> 交错路径与可增广路径</h3><p>设<code>M</code>是<code>G</code>中的一个匹配。若<code>G</code>的一条路径<code>P</code>中，属于<code>M</code>的边和不属于<code>M</code>的边<strong>交替</strong>出现，则称<code>P</code>为<code>M-交错路径</code>；</p><p>若<code>P</code>的起点和终点都是<code>M-非饱和点</code>，则称<code>P</code>是<code>可增广交错路径</code>。</p><h3 id="berge定理" tabindex="-1"><a class="header-anchor" href="#berge定理" aria-hidden="true">#</a> Berge定理</h3><p><code>M</code>是<code>G</code>的最大匹配，当且仅当<code>G</code>中不存在<code>M-可增广交错路径</code>。</p>',34),V={href:"https://www.mscs.dal.ca/~janssen/4115/presentations/Poppy.pdf",target:"_blank",rel:"noopener noreferrer"},f=o('<h3 id="稳定匹配问题" tabindex="-1"><a class="header-anchor" href="#稳定匹配问题" aria-hidden="true">#</a> 稳定匹配问题</h3><h4 id="偏好集" tabindex="-1"><a class="header-anchor" href="#偏好集" aria-hidden="true">#</a> 偏好集</h4><p><code>G</code>上的一个偏好集是一族线性序<code>(≤v), v∈V</code>；其中, <code>≤v</code>是<code>E(v)</code>上的线性序（对<code>v</code>相连的边进行排序）。</p><h4 id="稳定匹配" tabindex="-1"><a class="header-anchor" href="#稳定匹配" aria-hidden="true">#</a> 稳定匹配</h4><p><code>G</code>上的匹配<code>M</code>是稳定的，当且仅当对于<code>M</code>中任意一条边<code>e</code>, 存在边<code>f ∈ E - M</code>， 满足：</p><ul><li><code>e</code>和<code>f</code>有公共端点</li><li><code>e ≤v f</code>.</li></ul><h4 id="稳定匹配定理" tabindex="-1"><a class="header-anchor" href="#稳定匹配定理" aria-hidden="true">#</a> 稳定匹配定理</h4><p>对于任意给定的一个偏好集，图<code>G</code>有一个稳定的匹配（并不一定是完备匹配）。</p><h4 id="gale-sharpley算法" tabindex="-1"><a class="header-anchor" href="#gale-sharpley算法" aria-hidden="true">#</a> Gale-Sharpley算法</h4>',9),g={href:"https://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm",target:"_blank",rel:"noopener noreferrer"},_=o('<p><strong>以下的讨论均假设有一二部图<code>G = &lt;V1, V2, E&gt;</code>, 已经形成的匹配名为<code>M</code>。</strong></p><p><em>定义：<code>V1</code>中某点<code>u</code>对匹配的 <strong>“满意性”</strong>：若存在<code>V2</code>中匹配之外的一点<code>w</code>， 有<code>(u, w) ≤u (u, N(u))</code></em>.</p><p><em>定义2：<code>V2</code>中某点<code>v</code>是否可以接受与<code>V1</code>中的<code>u</code>匹配: 若满足<code>(u, v) ∈ E - M</code>， 且若存在<code>(u&#39;, v) ∈ M</code>， 则有<code>(u&#39;, v) &lt;v (u, v)</code>.</em></p><h5 id="算法过程" tabindex="-1"><a class="header-anchor" href="#算法过程" aria-hidden="true">#</a> 算法过程</h5><ol><li>选择<code>V1</code>中的一个尚未配对的顶点<code>u</code>, 在边集<code>{(u, v) | u 可以被 v 接受}</code>中按照线性序<code>≤u</code>找出符合条件的最大元，并将其添加至<code>M</code>中。同时，删除<code>M</code>中以<code>v</code>为端点的边。</li><li>循环(1)， 直至对于<code>V1</code>中的任意未配对顶点<code>u</code>，边集<code>{(u, v) | u 可以被 v 接受}</code>为空则结束算法。</li></ol><p><strong>正确性分析</strong>：当算法结束时，</p><ul><li><code>V1</code>中所有的未配对顶点均没有可以被接受的对象；</li><li><code>V1</code>中所有的顶点都对该匹配满意。</li><li>算法停止时<code>V2</code>的匹配情况比其他匹配情况更优：算法进行过程中，<code>V2</code>中的点只会接受比当前匹配好的匹配（“可被接受”的定义）。</li><li><code>M</code>是稳定的：</li></ul><blockquote><p>对于任意的<code>e ∈ E - M</code>， 均存在<code>f ∈ M</code>满足：</p><ul><li><code>e</code> 和 <code>f</code> 有公共端点；</li><li><code>e</code> &lt;v <code>f</code>.</li></ul></blockquote>',8);function b(m,v){const c=h("ExternalLinkIcon");return t(),i("div",null,[p,s,n(" more "),u,e("p",null,[d("证明参见： "),e("a",V,[d("Proof of Berge's Theorem"),a(c)])]),f,e("p",null,[e("a",g,[d("Wikipedia - Gale-Sharpley Algorithm"),a(c)])]),_])}const G=r(l,[["render",b],["__file","bipartite_graph_and_perfect_match.html.vue"]]);export{G as default};
