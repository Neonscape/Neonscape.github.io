import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as a,c as s,d as i,a as e,b as o,f as c,e as n}from"./app-259081b6.js";const h="/assets/imgs/bgs/8.png",l={},_=e("h1",{id:"算法笔记-dijkstra单源最短路算法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#算法笔记-dijkstra单源最短路算法","aria-hidden":"true"},"#"),o(" 算法笔记：Dijkstra单源最短路算法")],-1),g=e("p",null,[e("s",null,"噫，好！")],-1),p=n('<hr><figure><img src="'+h+'" alt="好看的" tabindex="0" loading="lazy"><figcaption>好看的</figcaption></figure><h2 id="算法作用" tabindex="-1"><a class="header-anchor" href="#算法作用" aria-hidden="true">#</a> 算法作用</h2><p>Dijkstra算法是在<strong>正权值</strong>的图中，对于某个特定的<strong>源节点</strong>寻找所有节点到该节点的<strong>最短路径</strong>的一种算法。</p><h2 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h2><p>要执行Dijkstra算法，需要如下元素：</p><ul><li>一张<strong>没有负权重</strong>的带权图<code>G</code>.</li><li>一个标记数组<code>vis[]</code>，用于标记某个节点是否访问过.</li><li>一个距离数组<code>dis[]</code>，用于记录某一时刻<strong>已知的</strong>最短路径.</li><li>给定的源点<code>S</code>.</li></ul><h2 id="算法步骤" tabindex="-1"><a class="header-anchor" href="#算法步骤" aria-hidden="true">#</a> 算法步骤</h2><p>首先在距离数组中将源点到自身的距离设为0（显然可得），将源点到其他点的距离设为+INF（意为在当前已知的情况下无法到达）。</p><ol><li>选取当前距离数组中 <strong>距离源点最短的、且此前没有访问过（<code>vis[P] == 0</code>）</strong> 的节点<code>P</code>. 在初始情况下，我们选择的显然是源点<code>S</code>；<br>在确定选择以后将<code>vis[P]</code>设为1，意即已经访问过这个点了。</li><li>搜索每一条与<code>P</code>所连接的边，记为<code>&lt;P, E, D&gt;</code>（从<code>P</code>通过<code>E</code>连接到<code>D</code>）：<strong>若<code>vis[D] == 1</code>，则跳过该条边（D的最短路已经被计算过了）。</strong>；<br>有如下等式：<code>vis[D] = min(vis[D], vis[P] + w(E))</code>（<code>w(E)</code>为<code>E</code>的边权值）.<br><em>如何理解这一不等式</em>：不停的枚举<strong>从源点<code>S</code>出发、通过当前讨论的<code>P</code>点、终点是<code>D</code>的路径</strong>，若该路径的长度小于现有记录的路径的长度，则说明现有记录的路径的长度错误，应当更新。</li><li>在搜索完<code>P</code>所连接的每一条边、并更新vis数组的值以后，回到1.；当所有点都被访问过的时候，算法终止。</li></ol><h2 id="正确性证明" tabindex="-1"><a class="header-anchor" href="#正确性证明" aria-hidden="true">#</a> 正确性证明</h2>',11),f={href:"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},u=e("h2",{id:"关于负权边的说明",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#关于负权边的说明","aria-hidden":"true"},"#"),o(" 关于负权边的说明")],-1),k=e("p",null,"由于Dijkstra算法不会重复考虑已经被访问过的点，且该算法在选取顶点的时候优先选择当前距离源点距离最小的点，所以假设以下情况：",-1),m=e("p",null,"A -2-> B A -10-> C C -(-20)->B",-1),E=e("p",null,"在这种情况下，Dijkstra算法会优先选择B点，并且在此之后不再计算B点的最短路（即便存在一条更短的A->C->B的路径）。",-1),b=e("h2",{id:"todo-优先队列优化的dijkstra算法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#todo-优先队列优化的dijkstra算法","aria-hidden":"true"},"#"),o(" TODO：优先队列优化的Dijkstra算法")],-1);function x(D,B){const d=r("ExternalLinkIcon");return a(),s("div",null,[_,g,i("more"),p,e("p",null,[e("a",f,[o("算法正确性证明"),c(d)])]),u,k,m,E,b])}const P=t(l,[["render",x],["__file","dijkstra_notes.html.vue"]]);export{P as default};
