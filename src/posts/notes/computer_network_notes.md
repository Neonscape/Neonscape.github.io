---
article: true
author: Neonscape
date: 2024-06-04
image: /assets/imgs/bg_new/00095-3117391577.png
cover: /assets/imgs/bg_new/00101-142766746.png
category:
  - notes
tags:
  - Computer Network
---

# 2024 春 互联网计算 课程笔记

## 第一章 计算机网络与因特网

### 1 什么是主机？什么是端系统？

**所有连接到因特网的设备**都称为主机或端系统。

### 2 什么是分组？什么是协议？

当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段并为每段数据加上首部字节。这样**包含首部字节的的数据包**称为分组。

协议(protocol)定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和／或接收一条报文或其他事件所采取的动作。

### 3 什么是客户、服务器？

客户和服务器是两种不同类型的主机；客户一般是桌面 PC、移动 PC 和智能手机等，而服务器通常是更为强大的计算机。

### 4 电路交换、分组交换及对比

通过网络链路和交换机传输数据有两种基本方法：分组交换和电路交换。

#### 分组交换

报文分组(packet)通过通信链路和**分组交换机(packet switch)**传送。

分组交换机主要有两类： **路由器** 和 **链路层交换机**。

大多数分组交换机在链路的输入端使用 **存储转发传输(store-and-forward transmission)**。这种机制使得交换机在开始分组的转发之前**必须先接收到整个分组的内容**。

:::note
通过$N$条速率均为$R$的链路串联组成的路径发送一个长度为$L$的分组，端到端时延为

$$
d_{p2p} = N \frac{L}{R}
$$

:::

此外，在网络较拥堵的情况下，分组交换还可能出现因为传输速率较低而导致的排队时延，和分组交换机缓存有限而出现的丢包。

::: note 转发表
每台路由器都拥有一个转发表，其中存储了数个(IP 地址，出链路)对，用于搜索转发分组的出链路。
:::

#### 电路交换

电路交换在两个端系统进行通信期间，预留了通信所需要的资源（带宽等），并为之建立一条专门的连接。

电路交换网络中有两种复用形式， **频分复用(FDM)**和**时分复用(TDM)**.

对于 FDM，链路为每条链接专用一个频段。这个频段的宽度称为带宽。

对于 TDM，时间被划分为固定大小的时间帧，每个时间帧又被划分为等大小的若干时隙。当建立连接时，网络为该条链接指定每一帧中一个特定的时隙。

#### 分组交换与电路交换的对比

- 分组交换
  - 优点
    - 带宽共享效率高于电路交换
    - 灵活性强
    - 比电路交换更加简单有效，成本更低
  - 缺点
    - 端到端时延不确定
    - 传输可靠性较低
- 电路交换
  - 优点
    - 端到端时延很小
    - 连接稳定，不存在丢包、失序问题
    - 连接建立之后可以随时进行通信，实时性强
    - 既适用于传输模拟信号，也适用于传输数字信号
    - 设备控制比较简单
  - 缺点
    - 带宽共享效率低
    - 灵活性差
    - 成本较高

### 5 节点处理时延、排队时延、传输时延、传播时延、吞吐量

#### 时延

- 节点处理时延：路由器检查分组首部，并决定将分组导向何处所需要的时间（也可能包括检查错误的时间）
- 排队时延：分组在等待需要使用的链路传输其他分组所需要的时间
- 传输时延：分组在某条链路上传输所需要的时间（分组从路由器中被推出的时间按）
- 传播时延：分组中每个比特从链路起点到下一个路由器传播的时间。传播速率一般接近光速。
- **某个节点的总时延等于上述时延的总和**。

#### 吞吐量

- 瞬时吞吐量：在某一时刻某个主机接收文件的速率。
- 平均吞吐量：某个主机在某一段时间内接收数据的量和时间的比值。
- 一般来说，某台主机通过某条链路接收数据的吞吐量取决于链路各个环节吞吐量中的最小值（瓶颈链路）。

### 6 因特网协议栈

#### 应用层

包含网络应用程序和它们的应用层协议，如 HTTP, SMTP, FTP, DNS 等。

应用层协议分布在多个端系统上；多个端系统上的应用程序之间使用应用协议交换信息分组。

这种位于应用层的信息分组称为 **报文(message)**.

#### 运输层

运输层在应用程序端点之间传送应用层报文。因特网中的运输协议有两种，TCP（确保传递，有流量和拥塞控制）和 UDP（不确保传递，没有流量和拥塞控制）。

这种位于运输层的信息分组称为 **报文段(segment)**.

#### 网络层

位于网络层的信息分组称为 **数据报(datagram)**.

运输层协议会将运输层报文段和目的地址递交给网络层，由网络层负责运输。

网络层包括网际协议 **IP**。IP 协议定义了数据报中的各个字段和作用。

#### 链路层

链路层负责将网络层的数据报从网络中的一个节点移动到路径上的下一个节点。

网络层负责端系统到端系统的可靠传输，而链路层负责一段链路上的两个节点之间的可靠传输。

位于链路层的信息分组称为 **帧(frame)**.

#### 物理层

物理层负责将链路层帧的每个比特从一个节点移动到下一个节点。

## 第二章 应用层

### 1 应用程序体系结构

现代网络应用程序通常有两种体系结构： **客户-服务器体系结构** 和 **对等(P2P)体系结构**.

#### 客户-服务器体系结构

在 客户-服务器体系结构 中，有一个总是打开的主机，称为 **服务器**。它服务于来自其他许多主机（称为 **客户** ）的请求。

::: note
在客户-服务器体系结构中，

- 客户之间并不直接互相沟通。
- 服务器有一个固定、周知的 IP 地址。

:::

采用客户-服务器体系结构的典型应用程序有 FTP, Web, Telnet 和电子邮件。

#### 对等体系结构

在 对等体系结构 中，应用程序在 _间断连接的主机对_ 之间使用直接通信。 这些主机对被称为 对等方(peer).

这种对等方通信不需要通过专门的服务器。

在应用对等体系结构的网络程序中，通常会有服务器被用于跟踪用户的 IP 地址；但用户到用户的数据不需要通过中间服务器发送。

采用对等体系结构的典型应用程序有 文件共享(BitTorrent)，P2P 下载器，网络电话和视频会议。

P2P 体系结构的最大特性是 **自扩展性**。

### 2 TCP 和 UDP 的区别

- TCP 提供面向连接的服务和可靠的数据传输服务——一条 TCP 连接是 全双工（可同时双向传输） 且 可靠（保证送达） 的。
- TCP 还提供拥塞和流量控制。
- UDP 只提供一种不可靠的数据传输服务，它不保证报文能够到达接收方，也不保证接收方接受的报文都是有序的。

### 3 HTTP

HTTP(HyperText Transfer Protocol, 超文本传输协议) 是 Web 的应用层协议，也是 Web 的核心。

HTTP 由两个程序实现：一个客户程序和一个服务器程序，它们通过交换 HTTP 报文进行会话。

HTTP 使用 TCP 作为运输协议。

首先，HTTP 客户端先发起一个和服务器的 TCP 连接；在连接建立之后，客户会通过自身的 TCP 套接字向服务器发送 HTTP 请求报文和接收 HTTP 响应报文，服务器也通过自身的套接字接受请求报文，发送响应报文。

HTTP 本身是一个无状态协议；它不会保存关于客户的任何信息，而是使用 cookie 来保存用户的相关信息。

::: note 关于 URL

每个 URL 由两部分组成： **存放对象的服务器主机名** 和 **对象的路径名**。

例如，`https://yafengnju.github.io/InternetComputing/%E6%80%BB%E5%A4%8D%E4%B9%A0.pdf`中，`https://yafengnju.github.io`就是主机名，而`/InternetComputing/%E6%80%BB%E5%A4%8D%E4%B9%A0.pdf`就是对象的路径。

:::

### 4 因特网电子邮件

电子邮件系统一般由三部分组成：

- 用户代理
- 邮件服务器
- 简单邮件传输协议(SMTP)

用户通过 **用户代理** 来将邮件发送到接收方的邮件服务器上，和从自己的邮件服务器上获取发给自己的邮件；

邮件服务器负责将发送方的报文发送给接收方的邮件服务器。

如果发送方的邮件服务器不能将邮件交付给接收方的邮件服务器（比如接收方的邮件服务器发生了故障），那么它会将这封邮件保存在一个报文队列中并再次尝试发送。如果多次发送均失败，发送方的邮件服务器则会通过电子邮件的形式通知发送方。

#### SMTP 的基本操作

- 发送方调用邮件代理程序并提供接收方的邮件地址，编写报文，然后通过用户代理发送报文。
- 发送方的用户代理将报文发送至发送方的邮件服务器，并被放在报文队列中。
- 发送方的邮件服务器上的 SMTP 客户端发现了该报文，并创建一条到接收方邮件服务器的 SMTP 服务器的 TCP 连接。
- 经过 SMTP 握手后，发送方服务器通过该 TCP 连接发送报文。
- 接收方邮件服务器接收该报文，并放入接收方邮箱中。
- 接收方调用用户代理阅读这条报文。

### 5 推协议和拉协议

如果一个协议中 TCP 连接是想要接收文件的主机发起的，那么这个协议就是拉协议。反之，如果一个协议中 TCP 连接是由想要发送文件的主机发起的，那么这个协议就是推协议。

### 6 域名系统(DNS)

一台因特网上的主机既可以用 IP 地址进行标识，也可以用 **主机名** 进行标识。

DNS 的作用：

- 将便于识记的主机名转换为便于路由器使用的 IP 地址。
- 提供主机别名（将多个主机名解析到同一个 IP 地址）。
- 提供邮件服务器别名。
- 负载分配（将对于部署在多个主机上的繁忙网站的请求解析到不同的主机上）。

DNS 由两部分组成：

- 一个由分层的 DNS 服务器实现的分布式数据库
- 一个使得主机能够查询上述数据库的 **应用层协议**

#### 分布式 DNS 服务器

DNS 服务器一般分为如下几种：

- 根 DNS 服务器
  - 提供顶级域 DNS 服务器的 IP 地址。
- 顶级域(TLD) DNS 服务器
  - 负责各个顶级域名和国家的顶级域名，如`.com`, `.org`, `.edu`, `.uk`等。
  - 提供权威 DNS 服务器的 IP 地址。
- 权威 DNS 服务器
  - 负责 **某个组织机构** 的 **公共可访问主机** 的域名解析。
- _本地 DNS 服务器_
  - 不属于 DNS 服务器的层次结构
  - 每个 ISP 都拥有自己的本地 DNS 服务器。
  - 负责代理本地主机的 DNS 请求。

#### 递归查询和迭代查询

- 递归查询：每一级 DNS 服务器都以自身的名义去查询自己的上一级服务器，在得到 DNS 结果后将回复层层向下传递。
- 迭代查询：某个主机（或服务器）不断地向不同的 DNS 服务器查询下一个需要查询的 DNS 服务器，直到获得 DNS 结果为止。

## 第三章 运输层

### 多路复用、多路分解

一台主机上可能有多个网络应用，每个应用都有一个或多个套接字来访问网络。

- 多路复用：运输层从所有套接字中收集数据块，并为每个数据块封装首部信息后生成报文段，然后传递到网络层。
- 多路分解：运输层从网络层接收到报文段之后，通过首部信息（源端口号、目的端口号）来将报文段中的数据交付到正确的套接字中。

### UDP / TCP 套接字

一台主机上的一个 UDP 套接字由（源端口号，目的端口号）唯一标识，而 TCP 套接字则由（源端口号，源 IP 地址，目的端口号，目的 IP 地址）标识；**（除非 TCP 报文段携带了创建初始链接的请求，）两个源 IP 地址不同的 TCP 报文将被发送到两个不同的 TCP 套接字。**

UDP 报文的结构：

```Table

| 16-bit src port | 16-bit dest port |
|     UDP len     |     checksum     |
|               Data                 |

```

### 使用 UDP 而非 TCP 的原因

::: note 为什么有些应用使用 UDP 而不使用 TCP？

- 在发送什么数据、何时发送的应用层控制，UDP 更加精细。
- 一些不需要建立连接的应用适合使用 UDP。（降低延时——不用建立连接）
- 一些不需要维护连接状态的应用适合使用 UDP。（不需要管理拥塞控制——可以支持更多流量）
- UDP 的分组首部（8bytes）开销小于 TCP（20bytes）。

:::

### UDP 检验和的计算

UDP 首先将报文段按照 16 比特分为数个字，然后将所有的字相加。

::: warning 注意：

UDP 计算检验和的时候使用循环加法，也就是**将加法中首位溢出的部分加到尾部**。

:::

假如有如下三个字：

```Text
0110011001100000
0101010101010101
1000111100001100
```

那么计算检验和的过程就是：

```Text
      0110011001100000
+     0101010101010101
----------------------
=     1011101110110101
+     1000111100001100
----------------------
=    *0100101011000010
~     （取反）
----------------------
=     1011010100111101

// *: 发生了溢出，将溢出的1加到末尾
```

因此最后的检验和值(checksum)是`1011010100111101`。

接收方接收到含有检验和的报文之后，按照同样的方式将所有的字相加。因为检验和在计算的时候进行了取反，所以正确的计算结果应当全部为 0。

如果 UDP 检测到了报文段发生错误，则它将丢弃该报文段。

::: note

注意：UDP 的检验和**无法校验偶数位**的错误。

:::

### TCP 的肯定确认、否定确认与自动重传请求协议

- 肯定确认：接收方在确认接收信息无误后发送一条肯定信息，表明确认信息收到。
- 否定确认：接收方在接收到模糊不清/有错误的信息后发送一条否定信息，表明需要重新传输该信息。
- 自动重传请求协议(ARQ)：基于上述两种重传机制实现的可靠数据传输协议。

具体来说，ARQ 中有三种协议功能来处理比特差错：

- 差错检测（包括检验和等方法） // TODO：差错检测方法
- 接收方反馈（包括 ACK（肯定确认）和 NAK（否定确认））
- 重传

### 停等协议、比特交替协议

- 停等协议：发送方发送一个分组后将停止发送并等待接收方的 ACK / NAK。
- 比特交替协议：
  - 是一种停等协议
  - 加入了分组序号以区分重传和正常传输
  - 加入了定时器（冗余风阻）功能以解决丢包问题

### 回退 N 步

回退 N 步协议（GBN）将所有分组分为 4 部分：

```Text

|已发送、已确认|已发送、还未确认|可发送、还未发送|不可发送|

```

其中，_已发送、还未确认_ 和 _可用、还未发送_ 的分组数量之和不能超过某个特定数值 `N`。 这个数值被称为 <u>窗口长度</u>；GBN 协议也因此经常被称为 <u>滑动窗口协议</u>.

当出现超时事件时，GBN 协议将回退到 _出现超时的分组_ ，并从该分组开始 _重传所有已经发送的分组_。

在使用 GBN 协议的传输中，接收方会丢弃所有失序分组。

GBN 的缺陷：有时可能会导致大量的重传（当发送窗口和时延都较大时）。

### 选择重传

在使用选择重传协议的传输中，接收方会逐个确认被正确接收的分组，并缓存失序的分组直到所有丢失分组都被收到为止。

选择重传也使用一个滑动的窗口来限制分组的发送，但不同的是选择重传的窗口起始位于第一个已发送但未收到确认的分组；发送窗口中可能会同时存在已经确认了的分组、已发送但还未确认的分组和可用但还未发送的分组。

在选择重传中，每个分组都有自己的逻辑定时器，并在定时器触发后只重传该分组。

::: warning 关于滑动窗口大小

在流水线传输协议中，一般窗口大小应当小于等于序号空间的一半（以避免接收方将重传的序号当成新分组的序号（进行模运算之后））.

:::

// TODO

### TCP 发送数据的过程

对于发送方来说，TCP 会将应用程序发送来的数据存入握手时建立的发送缓存中，并定期从发送缓存中取出数据，包装成 TCP 报文并传递到网络层。

TCP 一次性从缓存中取出的数据量受限于 **最大报文段长度(Max Segment Size)**，而 MSS 又通常根据最初确定的 本地主机发送的 **最大链路层帧长度**，即 **最大传输单元(Max Transmission Unit)**. 二者之间一般的关系是 `MSS + 40 (TCP/IP 首部长度) = MTU`.

对于接收方来说，TCP 会将接收到的 TCP 报文段提取出数据并放置在该 TCP 连接的接收缓存中，供应用程序取用。

### TCP 报文段结构

TCP 报文段的组成如下：

```text
|Src Port Number| Dest Port Number|
|              Seq                |
|        Acknowledge Number       | // 用于接收方发给发送方时标志 “期望收到的下一字节的序号”。
|Header Len|Reserved|*|Recv Window| // 接收窗口用于流量控制。
|    Checksum   | Urgent Data Ptr |
|            Options              | // 可选、变长；一般为空。
|             Data                |
```

`*`: 标志字段(`flags`)。包括`ACK`（确认字段有效）, `RST`, `SYN`, `FIN`（用于连接建立和拆除）, `CWR`, `ECE`（明确拥塞通告）, `URG`和`PSH`。在实践中，紧急数据指针、`URG`和`PSH`并不使用。

::: note 关于序号

注意 TCP 连接是全双工的；也就是说，双方可以同时发送和接收数据。因此，从一方到另一方的传输和反向的传输 **可能使用不同的序号**。

:::

### 流量控制、拥塞控制

**流量控制是一个速度匹配服务**：将发送方的发送速率和接收方的接收速率相匹配。

**拥塞控制**则是指发送方的行为因 IP 网络的拥塞而被遏制。

### TCP 的三次握手

两台主机建立 TCP 连接的过程如下：

- 首先，客户端的 TCP 向服务端 TCP 发送 **SYN 报文段**。
  - 这个报文段中不包含应用数据，但 **`SYN`标志为 1**。
  - 客户还将随机选择一个初始序号(`client_isn`)并放置在序号字段中。
- 来自客户端的 SYN 报文段到达服务器后，服务器会为该 TCP 链接分配 TCP 缓存和各个变量，并向客户端发送 **SYNACK 报文段**。
  - SYNACK 报文段中不包含应用层数据，但
    - `SYN`标志为 1
    - 确认号会被置为 `client_isn + 1`.
    - 服务器会随机选择自身的初始序号(`server_isn`)并放置在序号中。
- 客户端收到 SYNACK 报文段后，为该 TCP 链接分配缓存和变量，并发送对 SYNACK 报文段的确认。
  - 该确认报文中，确认字段为`server_isn + 1`.
  - `SYN`标志为 0（连接已经建立）。

### TCP 的拥塞控制

一个 TCP 连接会维护如下几个变量：

- `LastByteRead`:接收方从缓存读出的最后一个字节的编号。
- `LastByteRcvd`:接收方放入缓存的最后一个字节编号。
- `rwnd`: 接收窗口。
- `LastByteAcked`:发送方收到确认的最后一个字节的编号。
- `LastByteSent`:发送方发送的最后一个字节的编号。

以上变量满足如下关系：

- `LastByteRcvd - LastByteRead <= RcvBuffer` （禁止缓存溢出）
- `rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)` （接收窗口 = 接收方缓存剩余空间）
- `LastByteSent - LastByteACKed <= rwnd` （发送方保证不造成接收方缓存溢出）

此外，发送方额外维护一个变量`cwnd`（拥塞窗口），并引入如下规则：

`LastByteSent - LastByteACKed <= min {rwnd, cwnd}`

**假设接收方缓存大小无穷大**，则上述规则约束了 TCP 发送方在每个往返时间(RTT)中最多发送`cwnd`字节的数据——发送数据的速率大约是 `cwnd / RTT`B/s.

以下条件会被发送方判断为出现丢包（标志此时链路已经出现拥塞）。

- 超时
- 收到 **三个冗余 ACK** （一个初始 ACK 和三个重复的 ACK）

TCP 的拥塞控制算法按照以下原则进行：

- 出现丢包事件意味着出现拥塞，此时应当降低发送速率。
- 接收到一个（非冗余的）确认报文段意味着“一切顺利”，此时应当增加发送速率。
- TCP 将不断增加传输速率，直到出现丢包才减少。

#### 1 慢启动

当一条 TCP 连接开始时，cwnd 通常被设置为一个较小的值（如一个 MSS），并为每个被确认的报文段将 cwnd 增加一个 MSS。

:::note

注意：这种增长方式是指数而非线性的（每次增加上次发送的报文段数量的 MSS）。

:::

当 **出现一个由超时指示的丢包事件**， TCP 发送方就将`cwnd`重置为 一个 MSS ，并将另一个变量`ssthreshold`（慢启动阈值）设置为`cwnd / 2`（出现丢包前的最大 cwnd 的一半）。

**此后，当 cwnd 到达或超过`ssthreshold`的值时，结束慢启动并转移至拥塞避免模式。**

#### 2 拥塞避免

当进入拥塞避免模式后，TCP **在每个 RTT 时间内** 只会将`cwnd`增加一个 MSS。(按照 **时间** 增加，区别于慢启动阶段按照 确认数量 增加)。

当出现 **由超时指示的丢包** 时，TCP 将把 `cwnd` **设置为一个 MSS**，并将`ssthreshold`更新为 发生丢包前`cwnd`的一半，然后进入快速恢复状态。

当出现 **由 3 个冗余 ACK 指示的丢包** 时，

- TCP Reno 仅将`cwnd`的值 **减半** （并为 3 个已经接收到的 ACK 加上 3 个 MSS），并将`ssthreshold`更新为 发生丢包前`cwnd`的一半，然后进入 **快速恢复** 状态。
- TCP Tahoe 将`cwnd`再次设置为一个 MSS，将`ssthreshold`更新为 发生丢包前`cwnd`的一半，并进入 **慢启动** 状态。

#### 3 快速恢复

在进入快速恢复时，TCP 会将`cwnd`设为 `(ssthreshold + DuplicateACKs * MSS)`，然后立即重传它认为丢失的报文。

此后，每当收到一次对于上述报文的冗余 ACK（说明之前发送了其他的报文且被接收了），就将`cwnd`增加一个 MSS。

维持上述状态，直到收到一个对新的报文段的 ACK，转入拥塞控制模式。

## 第四章 网络层：数据平面
