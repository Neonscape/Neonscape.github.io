---
article: true
author: Neonscape
date: 2023-12-29
image: /assets/imgs/bgs/20230912(33).png
cover: /assets/imgs/bgs/20230912(34).png
category: 
- notes
tags:
- computer organization
---

# 计算机组织与结构 期末复习

## 计算机系统概述

### 计算机硬件的基本组成

#### 冯·诺依曼结构

计算机由如下结构组成：

- 运算器（执行算术和逻辑运算）
- 控制器（控制指令的执行）
- 存储器（存储数据和指令）
- 输入设备
- 输出设备

#### 现代计算机

现代计算机一般有如下结构：

- 中央处理器
  - 运算器
  - 控制器
  - 寄存器
- 存储器
  - 内存
  - 外存
- 外部设备、设备控制器
- 总线

### 计算机软件的分类

- 应用软件（专门为某种任务编写的程序）
- 系统软件（为有效、安全的使用和管理计算机，以及为开发和运行应用软件而提供的软件；位于计算机硬件和应用软件之间）
  - 操作系统
  - 语言处理系统
  - 数据库管理系统
  - ...

### 计算机系统的抽象层及其转换

计算机系统中的层次结构如下

- 应用（具体问题）
- 算法
- 编程语言
- 操作系统 / 虚拟机
- 指令集体系结构（**软件能感知到的最低层次**）
- 微体系结构
- 功能部件
- 电路
- 元器件

这些层次中，每一层都是对下一层的抽象；下层为顶层提供支撑。

### 用户CPU时间计算

#### 概念

用户使用计算机时所感到的响应时间一般分为 **用户CPU时间（用来运行用户代码的时间）** 和 其他时间（运行操作系统、等待IO、运行其他用户的程序的时间）。

**系统性能**指的是**整个计算机系统**的响应时间，包含CPU与其他部分；\
**CPU性能**单指用户CPU时间。

计算机系统的性能主要考虑CPU性能。

#### 计算

*CPI：执行一条指令所需要的时钟周期数。*

**CPU执行时间**：

- = 程序总时钟周期数 / 时钟频率
- = 程序总时钟周期数 * 时钟周期

**程序总时钟周期数**：

- = 程序总指令条数 * **平均CPI**
- = $\sum_{i = 1}^{n} {CPI_i \times C_i}$

**计算机性能之比**是**用户CPU时间之比**的**倒数**。

### Amdahl定律

$$
改进后的执行时间 = \frac{改进部分的执行时间}{改进部分的改进倍数} + 未改进部分的执行时间
\\
整体的改进倍数 = \frac{1}{\frac{改进部分执行时间的比例}{改进部分的改进倍数}+未改进部分执行时间比例}
\\
\left(p = \frac{1}{\frac{t}{n} + (1 - t)} \right)
$$

## 数据的机器级表示

### 进制数之间的转换

小数的转换：乘以基数，取整数部分作为每一位的值

### 原码、补码、移码表示法

#### 原码

原码的表示方式如下

- 最高位为符号位
- 此外其他位代表$2^n$

#### 补码

补码：对于模为`M`下的某一数`m`：

- `m >= 0` : `m`补 = `m`
- `m < 0` : `m`补 = `M - |m|`

> - 一个负数的补码等于模减该负数的绝对值。
> - 对于某个模`m`，`y < m`, 有`x - y = x + (-y)补`.
> - 二进制下，负数的补码等于对应正数补码的“取反加一”

> 变形补码：在原补码的最高位后加一位，用来处理溢出

#### 移码

移码表示下，所有数值都被加上了一个 **偏置常数**， 用于将含有负数的数值映射到正整数范围内。

**常用于表示浮点数的阶码**。

### 无符号整数和带符号整数的表示

**无符号整数**：某编码的所有二进制位都用于表示数据而没有符号表示。

**有符号整数**：编码中存在一个用于表示符号的二进制位。

::: info
有符号整数和无符号整数有如下区别：

- 扩充操作有区别（无符号整数通常使用0扩展，有符号整数使用符号为扩展）
- 数的比较有区别（符号位）
- 溢出判断有区别（无符号数通常不进行溢出判断）
:::

::: info LSB & MSB
LSB指“**最低有效位**”，MSB指“**最高有效位**”。
:::

### 浮点数的表示与IEEE 754标准

#### 浮点数的表示

**规格化小数**：科学记数法表示；小数点之前只有一位非0数。

**二进制的规格化小数表示**：

`|0（符号位）S|1～8（阶码）E|9～31（尾数）T|`

`val = (S? -1 : 1) * 0.1T * 2^E`.

::: warning
规格化小数的尾数第一位总是1,**省略不表示**。
:::

#### IEEE 754

IEEE754所规定的两种浮点数标准如下：

**单精度**：`|0（符号）s|1～8（阶码）e|9～31（尾数）f|`

**双精度**：`|0（符号）s|1～11（阶码）e|12～63（尾数）f|`

`val_f = (s ? -1 : 1) * (1.f) * 2^(e - 127)`

`val_lf = (s ? -1 : 1) * (1.f) * 2^(e - 1023)`

### C语言中的整数和浮点数

::: info
C语言在进行无符号数和有符号数的比较时，通常会将**有符号整数强制转换为无符号整数**，再按照无符号整数比较的规则进行比较。
:::

### 数据的存储和排列顺序

#### 西文和汉字字符的存储和表示

西文字符：ASCII码表示，字符串操作

汉字字符：包含输入码（按键=>汉字）、内码（系统内部编码）、字模码（编码=>点阵）

#### 数据的宽度和存储

- bit：0 / 1
- byte：8 bit
  - *最小可寻址单位*
- word：2/4/8/16 byte

**字长**：定点运算数据通路的宽度。字!=字长！

#### 数据的排列顺序

数据有两种方式，**大端序**和**小端序**。

**大端序**：以 **MSB** 所在的位置作为该数的地址。\
**小端序**：以 **LSB** 所在的位置最为该数的地址。

## 运算方法和运算部件

### 常见的汇编指令（MIPS）

```MIPS assembly
add $rd, $rs, $rt   | rd = rs + rt
addu $rd, $rs, $rt  | rd = rs + rt (unsigned, no overflow)
addi $rd, $rs, imm  | rd = rs + imm
addiu $rd, $rs, imm | rd = rs + imm
sub $rd, $rs, $rt   | rd = rs - rt
subu $rd, $rs, $rt  | rd = rs - rt (unsigned, no overflow)
mul $rd, $rs, $rt   | rd = rs * rt (no overflow)
mult $rs, $rt       | [$hi | $lo] = rs * rt
div $rs, $rt        | rs / rt = $lo ... $hi
and $rd, $rs, $rt   | rd = rs & rt
or $rd, $rs, $rt    | rd = rs | rt
xor $rd, $rs, $rt   | rd = rs ^ rt
nor $rd, $rs, $rt   | rd = !(rs | rt)
```

### 串行、并行、带标志的加法器原理

#### 串行进位加法器

**对于单个加法器**

- 输入：
  - `A`,加数某一位
  - `B`,被加数某一位
  - `Cin`,进位
- 输出：
  - `F = A ^ B ^ Cin`,结果
  - `Cout = A & B + A & Cin + B & Cin`,进位

串行加法器的工作原理：在前一位的运算得出`F`和`Cout`后，将`Cout`传递至下一个加法器开始运算。

::: info 一些结论
`n`位串行加法器从`C0`到`Cn`的延迟时间为`2 * n`级门延迟。

最后一位和数的延迟时间为`2 * n + 1`级门延迟。
:::

#### 并行进位加法器

定义两个辅助函数：

- $G_i = X_i Y_i$ (Carry Generation Function, 进位产生函数)
- $P_i = X_i + Y_i$ (Carry Propagation Function, 进位传递函数)

则有如下全加逻辑方程：

$F_i = G_iC_i, C_{i+1} = P_iC_i + G_i$.

将每个$C_i$展开可得，每个进位可独立得到，之间不存在相互依赖关系。

由此可制作出用于独立产生进位信号的元件，一般按照4位一组，称为 **4位先行进位部件（4位CLU）**。

#### 带标志加法器原理

带标志加法器多了几个标志位：

- 溢出标志`OF`: $OF = C_n \oplus C_{n-1}$
- 符号标志`SF`: $SF = F_{n-1}$
- 零标志`ZF`: $ZF = 1 \leftrightarrow F = 0 \text{（所有F都为0）}$
- 进位借位标志`CF`: $CF = C_{out} \oplus C_{in}$

### 补码的加减运算

**运算公式**：

- `[X + Y]补 = [X]补 + [Y]补 (mod 2^n)`
- `[X - Y]补 = [X]补 + [-Y]补 (mod 2^n)`

:::info 需要注意的事情

- 加减法统一采用加法运算；
- 符号位和数值位一起参与运算

:::

### 原码、补码的乘除

### 乘除运算溢出的判断、常量的乘除运算

### 浮点数的加减运算与舍入方式

## 指令系统

### 指令格式设计

### 操作数类型、寻址方式、操作类型、操作码编码

### 异常和中断的区别

### MIPS指令的格式和寻址方式

### 选择结构、循环结构的汇编表示

### 过程调用指令、执行步骤、栈和栈帧的变化

## 中央处理器

### CPU执行指令的过程

### CPU的基本组成、操作元件和状态元件

### 指令周期和时钟周期

### MIPS的指令格式、典型的MIPS指令

### 典型的MIPS指令数据通路、单周期数据通路设计、局部数据通路、控制信号的取值

### 多周期数据通路的设计、控制信号的取值

### 微程序控制处理器

### 带异常处理的数据通路、有限状态机

## 指令流水线

### 指令流水线的组成流水段

### MIPS指令的功能段划分、流水线数据通路的设计、控制信号的取值

### 结构冒险

### 数据冒险、转发技术、load-use的检测和处理

### 控制冒险、静态预测、动态预测、延迟分支

### 异常和中断引起的控制冒险

## 存储器层次结构

### 存储器的分类、主存储器的组成和基本操作、存储器的层次化结构

### SRAM和DRAM的区别

### 存储器芯片的扩展

### 连续编址方式、交叉编址方式

### 磁盘读写的三个步骤

### 磁盘存储器的性能指标

### 数据校验的基本原理、奇偶校验码、循环冗余校验码

### 程序访问的局部性

### Cache的基本工作原理

### 直接映射、全相连映射、组相连映射（命中率、命中时间、缺失损失、平均访问时间）

### 先进先出算法、最近最少用算法

### 全写法、回写法的区别

### 虚拟存储器的基本概念

### 进程的虚拟地址空间划分

### 分页式虚拟存储器的工作原理（页表、地址转换、快表、CPU访存过程）

## 系统互连、输入输出组织

### 外设的分类

### 总线、系统总线、数据线、地址线、控制线

### 基于总线的互连结构 （主要模块以及连接的总线）

### I/O接口的职能、I/O接口的通用结构

### I/O端口的独立编址方式、统一编址方式

### 程序直接控制I/O方式、中断控制I/O方式、DMA方式的工作原理、区别

### 中断响应、中断处理中断优先权的动态分配

### 3种DMA方式：CPU停止法、周期挪用法、交替分时访问法

### I/O子系统层次结构每层的基本功能

### 用户程序、C语言库、内核之间的关系
