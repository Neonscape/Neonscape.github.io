---
article: true
author: Neonscape
date: 2023-12-29
image: /assets/imgs/bgs/20230912(33).png
cover: /assets/imgs/bgs/20230912(34).png
category: 
- notes
tags:
- computer organization
---

# 计算机组织与结构 期末复习

## 计算机系统概述

### 计算机硬件的基本组成

#### 冯·诺依曼结构

计算机由如下结构组成：

- 运算器（执行算术和逻辑运算）
- 控制器（控制指令的执行）
- 存储器（存储数据和指令）
- 输入设备
- 输出设备

#### 现代计算机

现代计算机一般有如下结构：

- 中央处理器
  - 运算器
  - 控制器
  - 寄存器
- 存储器
  - 内存
  - 外存
- 外部设备、设备控制器
- 总线

### 计算机软件的分类

- 应用软件（专门为某种任务编写的程序）
- 系统软件（为有效、安全的使用和管理计算机，以及为开发和运行应用软件而提供的软件；位于计算机硬件和应用软件之间）
  - 操作系统
  - 语言处理系统
  - 数据库管理系统
  - ...

### 计算机系统的抽象层及其转换

计算机系统中的层次结构如下

- 应用（具体问题）
- 算法
- 编程语言
- 操作系统 / 虚拟机
- 指令集体系结构（**软件能感知到的最低层次**）
- 微体系结构
- 功能部件
- 电路
- 元器件

这些层次中，每一层都是对下一层的抽象；下层为顶层提供支撑。

### 用户CPU时间计算

#### 概念

用户使用计算机时所感到的响应时间一般分为 **用户CPU时间（用来运行用户代码的时间）** 和 其他时间（运行操作系统、等待IO、运行其他用户的程序的时间）。

**系统性能**指的是**整个计算机系统**的响应时间，包含CPU与其他部分；\
**CPU性能**单指用户CPU时间。

计算机系统的性能主要考虑CPU性能。

#### 计算

*CPI：执行一条指令所需要的时钟周期数。*

**CPU执行时间**：

- = 程序总时钟周期数 / 时钟频率
- = 程序总时钟周期数 * 时钟周期

**程序总时钟周期数**：

- = 程序总指令条数 * **平均CPI**
- = $\sum_{i = 1}^{n} {CPI_i \times C_i}$

**计算机性能之比**是**用户CPU时间之比**的**倒数**。

### Amdahl定律

$$
改进后的执行时间 = \frac{改进部分的执行时间}{改进部分的改进倍数} + 未改进部分的执行时间
\\
整体的改进倍数 = \frac{1}{\frac{改进部分执行时间的比例}{改进部分的改进倍数}+未改进部分执行时间比例}
\\
\left(p = \frac{1}{\frac{t}{n} + (1 - t)} \right)
$$

## 数据的机器级表示

### 进制数之间的转换

小数的转换：乘以基数，取整数部分作为每一位的值

### 原码、补码、移码表示法

#### 原码

原码的表示方式如下

- 最高位为符号位
- 此外其他位代表$2^n$

#### 补码

补码：对于模为`M`下的某一数`m`：

- `m >= 0` : `m`补 = `m`
- `m < 0` : `m`补 = `M - |m|`

> - 一个负数的补码等于模减该负数的绝对值。
> - 对于某个模`m`，`y < m`, 有`x - y = x + (-y)补`.
> - 二进制下，负数的补码等于对应正数补码的“取反加一”

> 变形补码：在原补码的最高位后加一位，用来处理溢出

#### 移码

移码表示下，所有数值都被加上了一个 **偏置常数**， 用于将含有负数的数值映射到正整数范围内。

**常用于表示浮点数的阶码**。

### 无符号整数和带符号整数的表示

**无符号整数**：某编码的所有二进制位都用于表示数据而没有符号表示。

**有符号整数**：编码中存在一个用于表示符号的二进制位。

::: info
有符号整数和无符号整数有如下区别：

- 扩充操作有区别（无符号整数通常使用0扩展，有符号整数使用符号为扩展）
- 数的比较有区别（符号位）
- 溢出判断有区别（无符号数通常不进行溢出判断）
:::

::: info LSB & MSB
LSB指“**最低有效位**”，MSB指“**最高有效位**”。
:::

### 浮点数的表示与IEEE 754标准

#### 浮点数的表示

**规格化小数**：科学记数法表示；小数点之前只有一位非0数。

**二进制的规格化小数表示**：

`|0（符号位）S|1～8（阶码）E|9～31（尾数）T|`

`val = (S? -1 : 1) * 0.1T * 2^E`.

::: warning
规格化小数的尾数第一位总是1,**省略不表示**。
:::

#### IEEE 754

IEEE754所规定的两种浮点数标准如下：

**单精度**：`|0（符号）s|1～8（阶码）e|9～31（尾数）f|`

**双精度**：`|0（符号）s|1～11（阶码）e|12～63（尾数）f|`

`val_f = (s ? -1 : 1) * (1.f) * 2^(e - 127)`

`val_lf = (s ? -1 : 1) * (1.f) * 2^(e - 1023)`

### C语言中的整数和浮点数

::: info
C语言在进行无符号数和有符号数的比较时，通常会将**有符号整数强制转换为无符号整数**，再按照无符号整数比较的规则进行比较。
:::

### 数据的存储和排列顺序

#### 西文和汉字字符的存储和表示

西文字符：ASCII码表示，字符串操作

汉字字符：包含输入码（按键=>汉字）、内码（系统内部编码）、字模码（编码=>点阵）

#### 数据的宽度和存储

- bit：0 / 1
- byte：8 bit
  - *最小可寻址单位*
- word：2/4/8/16 byte

**字长**：定点运算数据通路的宽度。字!=字长！

#### 数据的排列顺序

数据有两种方式，**大端序**和**小端序**。

**大端序**：以 **MSB** 所在的位置作为该数的地址。\
**小端序**：以 **LSB** 所在的位置最为该数的地址。

## 运算方法和运算部件

### 常见的汇编指令（MIPS）

```MIPS assembly
add $rd, $rs, $rt   | rd = rs + rt
addu $rd, $rs, $rt  | rd = rs + rt (unsigned, no overflow)
addi $rd, $rs, imm  | rd = rs + imm
addiu $rd, $rs, imm | rd = rs + imm
sub $rd, $rs, $rt   | rd = rs - rt
subu $rd, $rs, $rt  | rd = rs - rt (unsigned, no overflow)
mul $rd, $rs, $rt   | rd = rs * rt (no overflow)
mult $rs, $rt       | [$hi | $lo] = rs * rt
div $rs, $rt        | rs / rt = $lo ... $hi
and $rd, $rs, $rt   | rd = rs & rt
or $rd, $rs, $rt    | rd = rs | rt
xor $rd, $rs, $rt   | rd = rs ^ rt
nor $rd, $rs, $rt   | rd = !(rs | rt)
```

### 串行、并行、带标志的加法器原理

#### 串行进位加法器

**对于单个加法器**

- 输入：
  - `A`,加数某一位
  - `B`,被加数某一位
  - `Cin`,进位
- 输出：
  - `F = A ^ B ^ Cin`,结果
  - `Cout = A & B + A & Cin + B & Cin`,进位

串行加法器的工作原理：在前一位的运算得出`F`和`Cout`后，将`Cout`传递至下一个加法器开始运算。

::: info 一些结论
`n`位串行加法器从`C0`到`Cn`的延迟时间为`2 * n`级门延迟。

最后一位和数的延迟时间为`2 * n + 1`级门延迟。
:::

#### 并行进位加法器

定义两个辅助函数：

- $G_i = X_i Y_i$ (Carry Generation Function, 进位产生函数)
- $P_i = X_i + Y_i$ (Carry Propagation Function, 进位传递函数)

则有如下全加逻辑方程：

$F_i = G_iC_i, C_{i+1} = P_iC_i + G_i$.

将每个$C_i$展开可得，每个进位可独立得到，之间不存在相互依赖关系。

由此可制作出用于独立产生进位信号的元件，一般按照4位一组，称为 **4位先行进位部件（4位CLU）**。

#### 带标志加法器原理

带标志加法器多了几个标志位：

- 溢出标志`OF`: $OF = C_n \oplus C_{n-1}$
- 符号标志`SF`: $SF = F_{n-1}$
- 零标志`ZF`: $ZF = 1 \leftrightarrow F = 0 \text{（所有F都为0）}$
- 进位借位标志`CF`: $CF = C_{out} \oplus C_{in}$

### 补码的加减运算

**运算公式**：

- `[X + Y]补 = [X]补 + [Y]补 (mod 2^n)`
- `[X - Y]补 = [X]补 + [-Y]补 (mod 2^n)`

:::info 需要注意的事情

- 加减法统一采用加法运算；
- 符号位和数值位一起参与运算

:::

### 原码、补码的乘除

### 乘除运算溢出的判断、常量的乘除运算

#### 乘法溢出的判断

对于原码乘法：结果的高n位如果非全0则溢出。

对于补码乘法：结果的高n位如果和低n位的最高位不同则溢出。

#### 常量的乘除运算

**对于除运算**：

- 不能整除时，采用向0舍入（截断）方式。
  - 无符号数、带符号正整数：移出的低位直接丢弃（10 / 3 = 3）
  - 带符号整数：先加上负数偏移量（2 ^ k - 1），再右移k位，低位截断

### 浮点数的加减运算与舍入方式

浮点数在加减前需要对阶（使两数阶码相等）。

计算方式：

- 将阶码小的数尾数右移，使得两数阶码相等。
- 将对阶后的两数尾数相加。

:::warning
在对齐IEEE754浮点数时，尾数右移要将 **尾数中第一位隐含的1** 移动到小数部分。
:::

**判断溢出的方式**：

若最终阶码全为1则上溢（超过表示范围）

尾数全为0则下溢（精度不够）

## 指令系统

### 指令格式设计

#### 指令执行周期

- 取指令（Instruction Fetch）
- 指令译码（Instruction Decode）
- 计算地址、取操作数（Operand Fetch）
- 执行指令（Excecution）
- 保存计算结果（Result Store）

### 操作数类型、寻址方式、操作类型、操作码编码

#### 操作数类型

指令的操作数通常有如下类型：

- 指针 / 地址（作为无符号整数，用于确定主存地址）
- 数值数据
  - 定点数（二进制补码表示）
  - 浮点数（IEEE754）
  - 十进制数（NBCD码）
- 位、位串（表示标志、控制、状态等信息）
- 字符、字符串（表示文本）

#### 寻址方式

一共有七种基本寻址方式：

（假设：A = 地址字段值，R = 寄存器编号，EA = 有效地址（操作数的地址），（A） = A中的内容，P = 操作数的值）

- 立即寻址：P = A（执行快，但范围有限）
- 直接寻址：EA = A / P = （A）（计算简单，但范围有限）
- 间接寻址：EA = （A）（范围大，但需要多次存储器访问）
- 寄存器寻址：P = （R）（执行快，指令短，但范围有限）
- 寄存器间接寻址：EA = （R）（地址范围大，但需要额外存储器访问）
- 偏移寻址：EA = A + （R）（方式比较灵活，但太复杂）
  - 相对寻址：EA = A + （PC）：相对于当前指令位移量为A的单元（如PC+1）
    - 需要注意的是，这里需要先确定存储单元编址方式、偏移单位等信息才能确定目标地址范围。
  - 基址寻址：EA = A + （B）：相对于基址（B）处位移量为A的单元（）
  - 变址寻址：EA = A + （I（立即数））：相对于基址A处位移量为（I）的单元
- 堆栈寻址：EA = 栈顶（指令短，但应用有限）

#### 操作类型

- 算术和逻辑运算指令
- 移位指令
- 传送指令
- 串指令
- 顺序控制指令
- CPU控制指令
- 输入输出指令

#### 操作码编码

- 变长操作码（代码长度更重要）
- 定长操作码（性能更重要）

### 异常和中断的区别

中断分为两种：

- 内部异常：在CPU执行指令时内部发生的意外事件
  - 故障：执行指令时发生的异常事件（溢出、缺页、越界、越权、越级、非法指令、除0、堆栈溢出、访问超时）
  - 自陷：执行预先设置的指令（断点、系统调用等）
  - 终止：执行指令时出现了硬件故障
- 外部中断：在CPU外部发生的特殊事件（如时钟、控制台、打印机缺纸等）

#### 异常、中断的处理

- 检测和响应（硬件处理）
- 处理（软件完成）

当发生异常和中断时，系统将从用户态进入内核态来进行异常和中断的处理。

### MIPS指令的格式和寻址方式

- 位宽：等宽（32位）
- 三种指令格式
  - R-type：两个操作数和结果都在寄存器
    - |31 op 26|25 rs 21|20 rt 16|15 rd 11|10 shamt 6|5 func 0|
  - I-type：需要用到立即数的指令
    - |31 op 26|25 rs 21|20 rt 16|15 imm 0|
  - J-type：无条件跳转指令
    - |31 op 26|25 addr 0|

### 选择结构、循环结构的汇编表示

（没什么好看的）

### 过程调用指令、执行步骤、栈和栈帧的变化

#### 执行步骤

执行步骤（假设P调用Q）：

- （P）将参数放在Q能访问的地方
- （P）将P的返回地址存在特定的地方，转移控制至Q
- （Q）为局部变量分配空间（之前的变量存在栈中）
- （Q）执行Q
- （Q）将Q的返回结果放到P能访问到的地方
- （Q）取出返回地址，将控制转移回P

如果需要的参数超过4,返回值超过2,则需要将剩余的参数和返回值保存至栈中。

#### MIPS中的栈

- MIPS中的 **栈增长方向** 是 **从高地址向低地址增长**；
- MIPS栈的取数方向是 **大端序**。
- MIPS栈中，各个过程有各自的 **栈帧**。
- 每个栈帧都有自己的帧指针，用于指示栈帧开始的位置。
- 当前栈帧位于栈指针和帧指针之间。

#### MIPS寄存器的使用约定

- 保存寄存器`$s0 ~ $s7`的值在从被调用过程返回后仍然需要，需要由被调用着保留。
- 临时寄存器`$t0 ~ $t9`的值在从被调用过程返回后不再需要，（若需要的话可以由调用者保存）。
- 参数寄存器`$a0 ~ $a3`的值在从被调用过程返回后不再需要，（若需要的话可以由调用者保存）。
- 全局寄存器`$gp`的值不变
- 帧指针寄存器`$fp`的值用栈指针`$sp - 4`初始化
- 返回地址`$ra`的内容需要由被调用者保存

:::info 其他需要保存在栈中的内容

- 所有局部数组、结构等复杂变量
- 寄存器不够时的数据

:::

:::info 其他相关信息

- **全局静态变量一般分配到寄存器或者R/W存储区。**
- 通常来说栈帧寄存器都要保存。

:::

## 中央处理器

### CPU执行指令的过程

CPU执行指令的过程如下：

- 取指令
- PC自增
- 指令译码
- 计算主存地址
- 取操作数
- 算术 / 逻辑运算
- 存结果

> 以上每一步都需要检测是否有异常产生。若有异常，则切换至异常处理程序。
>
> 每一步同时需要检测是否有中断请求，有则转中断处理。

### CPU的基本组成、操作元件和状态元件

#### CPU的组成

CPU中包含：

- 数据通路（Datapath），指令执行过程中，数据所经过的路径（及路径上的部件），是指令的**执行部件**。
- 控制器（Control），负责生成指令对应的控制信号，控制数据通路的动作；是指令的控制部件。

数据通路由 **组合逻辑元件**（操作元件） 和 **时序逻辑元件**（状态元件/存储元件） 由 **总线连接方式** 或 **分散连接方式** 连接而成，负责 **数据的存储、处理、传送**。

#### 关于 **操作元件**
>
> - 加法器：不需要控制信号
> - 多路选择器（MUX）：需要 **选择信号**
> - 算术逻辑部件（ALU）：需要 **操作码（Opcode）**
> - 译码器（Decoder）：给出多个 **输出信号**
>
> 操作元件的特点：
>
> - 输出只取决于当前的输入
> - 输出端改变和输入端改变之间有固定的逻辑门延时，不需要时钟信号。

#### 关于 **状态元件**
>
> 状态元件的特点：
>
> - 具有存储功能，在 **时钟控制下** 输入被写入到电路中，直到下个时钟信号到达。
> - 时钟决定何时将输入端状态写入元件，但输出端可以随时读出
> - 使用边缘触发方式定时：状态单元的值只在时钟信号的边缘处改变，每个时钟周期改变一次。
>   - 上升沿触发
>   - 下降沿触发
>
> 状态元件有三个指标：
>
> - 建立时间（Setup）：在时钟信号到达前，输入信号需要维持多长时间稳定
> - 保持时间（Hold）：在时钟信号到达后，输入信号还需要维持多长时间稳定
> - 锁存延迟（Clock-to-Q）：从输入信号改变到输出信号改变的时间
>
> 常见的状态元件：
>
> - 寄存器
>   - 有一个写使能（Write-Enable）信号：使得时钟信号到来时输入端的值能够写入寄存器内。
> - 寄存器组
>   - 有三个地址线RA、RB和RW：给出需要读取和写入的存储单元地址
>   - 有两个输出口busA与busB：当RA与RB传入地址后，经过一个 **取数时间**， 输出对应单元的内容到busA与busB中。
>   - 有一个输入口busW：当输入信号RegWr（写使能）为真时，在下一个到来的时钟边沿将busW传来的值写入到地址在RW的寄存器中。

### 指令周期和时钟周期

#### 指令周期

**指令周期**指CPU取出并执行一条指令的时间；各指令的指令周期各不相同。

**时钟周期**在值上等于锁存延迟（Clock-to-Q）、最长传输延迟、建立时间（Setup）和时钟偏移的和（假设采用负跳变方式写入数据）。

### MIPS的指令格式、典型的MIPS指令

*见前指令集部分*。

### 典型的MIPS指令数据通路、单周期数据通路设计、局部数据通路、控制信号的取值

#### 单周期数据通路设计

以下为各条指令涉及的控制信号：

- add & sub 指令：RegWr（寄存器回写），ALUCtr（ALU加（符号/无符号） / 减（符号 / 无符号） / 或）
- ori 指令： ALUSrc（控制是R型指令（从寄存器中取值）还是I型指令（使用立即数））， RegDst（控制是否写入Rd寄存器（R型指令写入Rd,I型指令写入Rt））。
- lw指令：ExtOp（控制是符号扩展立即数（地址计算）还是0扩展立即数（立即数计算）），MemWr（主存写使能， sw使用），MemtoReg（控制主存写到寄存器中， lw使用）
- beq指令：Branch（是否跳转（到采用相对寻址计算出的地址））
- j 指令：Jump（是否跳转（到给出的绝对地址））

### 多周期数据通路的设计、控制信号的取值

以下是各控制信号的列表：

- PCWr：控制是否将新地址写入PC。
- PCWrCond：（在beq指令中，与Zero信号共同）决定是否跳转到新地址。
- IorD：控制从内存中读取的的是指令还是数据。
- MemWr：控制内存写使能。
- IRWr：控制指令寄存器（记录当前指令）的写使能。
- RegDst：控制是否向Rd中写入数据。
- ExtOp：控制对立即数进行扩展的类型。
- MemtoReg：控制回写到目标寄存器的是来自内存的内容还是来自ALU的内容。
- RegWr：控制寄存器堆的写使能。
- ALUSelA：控制送入ALU的第一个操作数的来源（PC / BusA）。
- ALUSelB：控制送入ALU的第二个操作数的来源（常量（4） / BusB / immExt << 2 / immExt）。
- PCSrc：控制送入PC的值的来源（提前计算好的Target还是ALU的结果）。
- BrWr：控制是否将ALU提前计算的PC的下一个值写入Target寄存器。
- ALUOp：控制ALU进行的运算种类。

#### 状态转换图

使用状态转换图控制处理器中不同控制信号的取值。

每一套取值都是转换图中的一个状态。

### 微程序控制处理器

#### 设计思路

编制每个指令所对应的微程序；每个微程序由若干微指令构成，而每个微指令又由若干条微命令组成。

微程序在不同的周期执行不同的微指令（包含一系列控制信号的取值，即“微命令”）。

所有指令对应的微程序存放在一个只读存储器（控制存储器，Control Storage）中。

#### 结构

- IR：存储当前需要查找对应微程序的指令。
- 起始和转移地址发生器：接受条件码，产生起始的微指令地址和下一条微指令的地址
- microPC：微指令计数寄存器，记录当前执行的微指令的地址
- 控制存储器：核心部件，存储所有的微程序、微指令和微命令
- microIR：微指令寄存器，存储当前的微指令
- Decoder：微指令解码器，将微指令解码成控制信号。

> 取指令和译码用专用的微程序实现；其他的指令由其他微程序实现。

#### 微指令的种类

- 水平型微指令：将相容的微命令尽量多的安排在同一条微指令中
  - 程序短、并行度高，但编码空间利用率低，编制困难。
- 垂直型微指令：一条微指令只控制一两个微命令。
  - 编码效率高，容易编制，但程序长，无并行，速度慢。

#### 微指令的内容

- 微操作码（生成微命令）
- 下一条微指令地址（可选）
- 常数（可选）

#### 微操作码的编码方式

- 不译法（直接控制）
  - 微指令字很长，空间利用率低。
  - 并行控制能力强，速度快。
- 字段直接编码
  - 把微指令分成若干字段。
  - 把互斥的（不能同时进行的）微操作编码在同一字段。
  - 一条微指令最多可同时发出的微命令个数就是字段数（各个字段同时开始执行）。
  - 并行控制能力高，速度快；微指令较短。
  - 增加译码时间和线路。
- 字段间接编码
- 最小编码译法

### 带异常处理的数据通路、有限状态机

**MIPS使用软件来识别中断源**。

#### MIPS处理器的异常处理

需要在数据通路中加入两个寄存器：

- EPC：存放断点（异常处理结束后返回到的指令地址）。
  - 其中可能是正在执行的指令地址（故障：EPC = PC - 4，PC在开始执行后已经自增了），也可能是下一条指令的地址（自陷和中断，EPC = PC）。
- Cause：记录异常原因。

需要加入两个控制信号：

- EPCWr：在保存断点时有效。
- CauseWr：在发现异常时有效。
- IntCause：选择正确的异常编码值来写入Cause中。

需要加入两个异常状态：

- UndefInstr：未定义指令异常
- Overflow：数据溢出异常

> **故障**在指令执行过程中检测。
>
> **自陷**在指令译码或者条件码检测中检测。
>
> **中断**在每条指令执行后检测（中断是随机发生的）。

## 指令流水线

### 指令流水线的组成流水段

一条指令流水线一般由如下五个流水段组成：

- 取指令（IF）：需要使用指令存储器，加法器
- 指令译码（ID）：需要使用寄存器堆读口，指令译码器
- 取操作数（OF）：需要使用扩展器，ALU
- 执行（EX）：需要使用内存
- 写回（WB）：需要使用寄存器堆写口

### MIPS指令的功能段划分、流水线数据通路的设计、控制信号的取值

#### 功能段的设计和划分

在进行指令流水线的设计时，我们将所有指令的长度使用nop指令和最长的Load指令对齐。

在指令流水线中，指令的流水段被分成如下阶段：

- Ifetch : 读指令
- Reg/Dec ： 从寄存器取数（register fetch），同时指令译码（decode）
- Exec：目标地址送PC,执行指令
- Mem：读取或写入存储器
- Wr：将读取 / 计算出的数据写回到寄存器中

以下是各指令对齐后的结果：

- Load: Ifetch, Reg/Dec, Exec, Mem, Wr
- R-type: Ifetch, Reg/Dec, Exec, **nop**, Wr
- Store: Ifetch, Reg/Dec, Exec, Mem, **nop**
- Beq: Ifetch, Reg/Dec, Exec, Mem, **nop**
- J: Ifetch, Reg/Dec, Exec, **nop**, **nop**

#### 数据通路的设计

指令流水线在各个阶段所涉及的部件之间加入了四个 **流水段寄存器**，用于保存各阶段计算的结果。

属于内部寄存器，对用户透明。

加入的寄存器如下：

- IF/ID （保存指令内容（下一阶段译码）和PC + 4的值（后续计算转移目标地址））
- ID/Ex （Reg[Rs], Reg[Rt], Rt, Rd, Imm16, PC + 4， **所有的控制信号**）
- Ex/Mem （MemWr, Branch, MemtoReg, RegWr）
- Mem/Wr （MentoReg, RegWr）

### 结构冒险

### 数据冒险、转发技术、load-use的检测和处理

### 控制冒险、静态预测、动态预测、延迟分支

### 异常和中断引起的控制冒险

## 存储器层次结构

### 存储器的分类、主存储器的组成和基本操作、存储器的层次化结构

### SRAM和DRAM的区别

### 存储器芯片的扩展

### 连续编址方式、交叉编址方式

### 磁盘读写的三个步骤

### 磁盘存储器的性能指标

### 数据校验的基本原理、奇偶校验码、循环冗余校验码

### 程序访问的局部性

### Cache的基本工作原理

### 直接映射、全相连映射、组相连映射（命中率、命中时间、缺失损失、平均访问时间）

### 先进先出算法、最近最少用算法

### 全写法、回写法的区别

### 虚拟存储器的基本概念

### 进程的虚拟地址空间划分

### 分页式虚拟存储器的工作原理（页表、地址转换、快表、CPU访存过程）

## 系统互连、输入输出组织

### 外设的分类

### 总线、系统总线、数据线、地址线、控制线

### 基于总线的互连结构 （主要模块以及连接的总线）

### I/O接口的职能、I/O接口的通用结构

### I/O端口的独立编址方式、统一编址方式

### 程序直接控制I/O方式、中断控制I/O方式、DMA方式的工作原理、区别

### 中断响应、中断处理中断优先权的动态分配

### 3种DMA方式：CPU停止法、周期挪用法、交替分时访问法

### I/O子系统层次结构每层的基本功能

### 用户程序、C语言库、内核之间的关系
